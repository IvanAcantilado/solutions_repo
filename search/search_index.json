{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Investigating the Range as a Function of the Angle of Projection Theoretical Foundation Derivation of the Equations of Motion Projectile motion is a form of two-dimensional motion under constant acceleration due to gravity. It can be derived from Newton\u2019s second law: \\[ \\vec{F} = m \\vec{a} \\] In the absence of air resistance, the only force acting on the projectile after launch is gravity. The motion can be decomposed into two orthogonal components: horizontal and vertical. Horizontal motion (constant velocity): \\[ x(t) = v_0 \\cos \\theta \\cdot t \\] Vertical motion (uniform acceleration): \\[ y(t) = v_0 \\sin \\theta \\cdot t - \\frac{1}{2} g t^2 \\] Where: - \\(v_0\\) is the initial velocity, - \\(\\theta\\) is the angle of projection, - \\(g\\) is the acceleration due to gravity, - \\(t\\) is the time. Range as a Function of Angle To determine the range \\(R\\) (the horizontal distance traveled when \\(y=0\\) ), solve \\(y(t) = 0\\) for \\(t \\neq 0\\) : \\[ t = \\frac{2 v_0 \\sin \\theta}{g} \\] Substitute this into the horizontal displacement: \\[ R(\\theta) = v_0 \\cos \\theta \\times \\frac{2 v_0 \\sin \\theta}{g} = \\frac{v_0^2 \\sin (2\\theta)}{g} \\] This expression reveals that the range is maximized when \\(\\theta = 45^\\circ\\) and symmetrically decreases for angles above or below this value. Family of Solutions The parametric nature of projectile motion means that by varying: \\(v_0\\) : changes the scale of motion, \\(\\theta\\) : alters the shape and symmetry, \\(g\\) : affects vertical acceleration (useful for different planetary conditions), initial height \\(h\\) (if added): modifies time of flight and total range, we obtain a family of trajectories \u2014 all governed by the same physical laws but producing a wide variety of outcomes. This makes projectile motion an excellent model for studying how initial conditions influence physical systems. Analysis of the Range Dependence on Angle of Projection The range function \\[ R(\\theta) = \\frac{v_0^2 \\sin (2\\theta)}{g} \\] indicates that: The maximum range occurs at \\(\\theta = 45^\\circ\\) because \\(\\sin(2\\theta)\\) reaches its peak value of 1 at \\(90^\\circ\\) . The range is symmetric about \\(45^\\circ\\) ; angles \\(\\theta\\) and \\(90^\\circ - \\theta\\) give the same range. Effect of Initial Velocity and Gravity Increasing \\(v_0\\) increases the range quadratically since \\(R \\propto v_0^2\\) . Increasing gravitational acceleration \\(g\\) decreases the range inversely: \\(R \\propto \\frac{1}{g}\\) . Influence of Launch Height If the launch height \\(h\\) is non-zero, the total flight time increases and the symmetry in range with respect to angle is lost. The range formula becomes more complex and must be found by solving the quadratic equation in \\(t\\) given by: \\[ y(t) = h + v_0 \\sin \\theta \\cdot t - \\frac{1}{2} g t^2 = 0 \\] The range is then: \\[ R(\\theta) = v_0 \\cos \\theta \\cdot t_{\\text{flight}} \\] where \\(t_{\\text{flight}}\\) is the positive root of the above quadratic. Practical Applications The idealized projectile model can be adapted or extended to more realistic situations: Uneven Terrain: Launch and landing heights differ, requiring adjustment of the time of flight and range calculations. Air Resistance: Drag forces slow the projectile, reducing range and changing optimal launch angle, often requiring numerical solutions. Wind Effects: Lateral forces cause trajectory deviation, adding complexity beyond two-dimensional motion. Sports: Optimizing angles in golf, basketball, or soccer to maximize distance or accuracy. Engineering and Ballistics: Designing trajectories for rockets or projectiles where precise targeting is crucial. Astrophysics: Calculations of orbital launches and landings on planets with different gravitational accelerations. These real-world factors motivate expanding the model beyond simple analytic solutions. Implementation Computational Simulation Develop a Python code to simulate projectile motion and analyze the range: Input parameters: initial velocity \\(v_0\\) , angle \\(\\theta\\) , gravitational acceleration \\(g\\) , and launch height \\(h\\) . Calculate the time of flight by solving \\(y(t) = 0\\) (for \\(h \\neq 0\\) , solve quadratic numerically). Compute the range as: \\[ R = v_0 \\cos \\theta \\times t_{\\text{flight}} \\] Sweep \\(\\theta\\) from \\(0^\\circ\\) to \\(90^\\circ\\) to plot \\(R(\\theta)\\) . Visualize representative projectile trajectories for selected angles. Show Code import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # gravity (m/s^2) v0 = 30 # initial velocity (m/s) h = 0 # launch height (m) angles = np.radians(np.linspace(0, 90, 100)) # angles in radians def compute_range(theta, v0, g, h=0): sin_theta = np.sin(theta) cos_theta = np.cos(theta) if h == 0: t_flight = 2 * v0 * sin_theta / g else: discriminant = (v0 * sin_theta)**2 + 2 * g * h t_flight = (v0 * sin_theta + np.sqrt(discriminant)) / g return v0 * cos_theta * t_flight ranges = np.array([compute_range(theta, v0, g, h) for theta in angles]) # Plot Range vs Angle plt.figure(figsize=(10, 6)) plt.plot(np.degrees(angles), ranges) plt.title('Range vs. Angle of Projection') plt.xlabel('Angle (degrees)') plt.ylabel('Range (m)') plt.grid(True) plt.savefig(\"range_vs_angle.png\") plt.show() # Plot Trajectories plt.figure(figsize=(10, 6)) for theta_deg in [15, 30, 45, 60, 75]: theta = np.radians(theta_deg) t_max = compute_range(theta, v0, g, h) / (v0 * np.cos(theta)) t = np.linspace(0, t_max, num=200) x = v0 * np.cos(theta) * t y = h + v0 * np.sin(theta) * t - 0.5 * g * t**2 plt.plot(x, y, label=f'{theta_deg}\u00b0') plt.title('Projectile Trajectories for Various Angles') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Height (m)') plt.legend() plt.grid(True) plt.savefig(\"trajectories.png\") plt.show() function toggleCode() { const codeBlock = document.getElementById(\"code-block\"); const button = document.querySelector(\"button\"); if (codeBlock.style.display === \"none\") { codeBlock.style.display = \"block\"; button.textContent = \"Hide Code\"; } else { codeBlock.style.display = \"none\"; button.textContent = \"Show Code\"; } } The simulation provides a hands-on way to explore how changing parameters affects projectile motion. Limitations and Proposed Extensions Limitations Assumes no air resistance or drag, which is unrealistic for most practical cases. Assumes constant gravitational acceleration and flat terrain. Neglects wind and lateral forces. Assumes instantaneous launch without propulsion after initial velocity. Proposed Extensions Incorporate drag force models (linear or quadratic) to simulate air resistance and its effect on range and trajectory. Add wind effects as lateral forces that affect horizontal displacement. Introduce terrain models with variable landing heights for more realistic conditions. Use numerical solvers (e.g., Runge-Kutta methods) to solve differential equations that do not have closed-form analytical solutions. These enhancements make the model closer to real-world physics, expanding its applicability in sports science, engineering, and astrophysics.","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#theoretical-foundation","text":"","title":"Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#derivation-of-the-equations-of-motion","text":"Projectile motion is a form of two-dimensional motion under constant acceleration due to gravity. It can be derived from Newton\u2019s second law: \\[ \\vec{F} = m \\vec{a} \\] In the absence of air resistance, the only force acting on the projectile after launch is gravity. The motion can be decomposed into two orthogonal components: horizontal and vertical. Horizontal motion (constant velocity): \\[ x(t) = v_0 \\cos \\theta \\cdot t \\] Vertical motion (uniform acceleration): \\[ y(t) = v_0 \\sin \\theta \\cdot t - \\frac{1}{2} g t^2 \\] Where: - \\(v_0\\) is the initial velocity, - \\(\\theta\\) is the angle of projection, - \\(g\\) is the acceleration due to gravity, - \\(t\\) is the time.","title":"Derivation of the Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-as-a-function-of-angle","text":"To determine the range \\(R\\) (the horizontal distance traveled when \\(y=0\\) ), solve \\(y(t) = 0\\) for \\(t \\neq 0\\) : \\[ t = \\frac{2 v_0 \\sin \\theta}{g} \\] Substitute this into the horizontal displacement: \\[ R(\\theta) = v_0 \\cos \\theta \\times \\frac{2 v_0 \\sin \\theta}{g} = \\frac{v_0^2 \\sin (2\\theta)}{g} \\] This expression reveals that the range is maximized when \\(\\theta = 45^\\circ\\) and symmetrically decreases for angles above or below this value.","title":"Range as a Function of Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#family-of-solutions","text":"The parametric nature of projectile motion means that by varying: \\(v_0\\) : changes the scale of motion, \\(\\theta\\) : alters the shape and symmetry, \\(g\\) : affects vertical acceleration (useful for different planetary conditions), initial height \\(h\\) (if added): modifies time of flight and total range, we obtain a family of trajectories \u2014 all governed by the same physical laws but producing a wide variety of outcomes. This makes projectile motion an excellent model for studying how initial conditions influence physical systems.","title":"Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#analysis-of-the-range","text":"","title":"Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#dependence-on-angle-of-projection","text":"The range function \\[ R(\\theta) = \\frac{v_0^2 \\sin (2\\theta)}{g} \\] indicates that: The maximum range occurs at \\(\\theta = 45^\\circ\\) because \\(\\sin(2\\theta)\\) reaches its peak value of 1 at \\(90^\\circ\\) . The range is symmetric about \\(45^\\circ\\) ; angles \\(\\theta\\) and \\(90^\\circ - \\theta\\) give the same range.","title":"Dependence on Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#effect-of-initial-velocity-and-gravity","text":"Increasing \\(v_0\\) increases the range quadratically since \\(R \\propto v_0^2\\) . Increasing gravitational acceleration \\(g\\) decreases the range inversely: \\(R \\propto \\frac{1}{g}\\) .","title":"Effect of Initial Velocity and Gravity"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#influence-of-launch-height","text":"If the launch height \\(h\\) is non-zero, the total flight time increases and the symmetry in range with respect to angle is lost. The range formula becomes more complex and must be found by solving the quadratic equation in \\(t\\) given by: \\[ y(t) = h + v_0 \\sin \\theta \\cdot t - \\frac{1}{2} g t^2 = 0 \\] The range is then: \\[ R(\\theta) = v_0 \\cos \\theta \\cdot t_{\\text{flight}} \\] where \\(t_{\\text{flight}}\\) is the positive root of the above quadratic.","title":"Influence of Launch Height"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#practical-applications","text":"The idealized projectile model can be adapted or extended to more realistic situations: Uneven Terrain: Launch and landing heights differ, requiring adjustment of the time of flight and range calculations. Air Resistance: Drag forces slow the projectile, reducing range and changing optimal launch angle, often requiring numerical solutions. Wind Effects: Lateral forces cause trajectory deviation, adding complexity beyond two-dimensional motion. Sports: Optimizing angles in golf, basketball, or soccer to maximize distance or accuracy. Engineering and Ballistics: Designing trajectories for rockets or projectiles where precise targeting is crucial. Astrophysics: Calculations of orbital launches and landings on planets with different gravitational accelerations. These real-world factors motivate expanding the model beyond simple analytic solutions.","title":"Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#implementation","text":"","title":"Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#computational-simulation","text":"Develop a Python code to simulate projectile motion and analyze the range: Input parameters: initial velocity \\(v_0\\) , angle \\(\\theta\\) , gravitational acceleration \\(g\\) , and launch height \\(h\\) . Calculate the time of flight by solving \\(y(t) = 0\\) (for \\(h \\neq 0\\) , solve quadratic numerically). Compute the range as: \\[ R = v_0 \\cos \\theta \\times t_{\\text{flight}} \\] Sweep \\(\\theta\\) from \\(0^\\circ\\) to \\(90^\\circ\\) to plot \\(R(\\theta)\\) . Visualize representative projectile trajectories for selected angles. Show Code import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # gravity (m/s^2) v0 = 30 # initial velocity (m/s) h = 0 # launch height (m) angles = np.radians(np.linspace(0, 90, 100)) # angles in radians def compute_range(theta, v0, g, h=0): sin_theta = np.sin(theta) cos_theta = np.cos(theta) if h == 0: t_flight = 2 * v0 * sin_theta / g else: discriminant = (v0 * sin_theta)**2 + 2 * g * h t_flight = (v0 * sin_theta + np.sqrt(discriminant)) / g return v0 * cos_theta * t_flight ranges = np.array([compute_range(theta, v0, g, h) for theta in angles]) # Plot Range vs Angle plt.figure(figsize=(10, 6)) plt.plot(np.degrees(angles), ranges) plt.title('Range vs. Angle of Projection') plt.xlabel('Angle (degrees)') plt.ylabel('Range (m)') plt.grid(True) plt.savefig(\"range_vs_angle.png\") plt.show() # Plot Trajectories plt.figure(figsize=(10, 6)) for theta_deg in [15, 30, 45, 60, 75]: theta = np.radians(theta_deg) t_max = compute_range(theta, v0, g, h) / (v0 * np.cos(theta)) t = np.linspace(0, t_max, num=200) x = v0 * np.cos(theta) * t y = h + v0 * np.sin(theta) * t - 0.5 * g * t**2 plt.plot(x, y, label=f'{theta_deg}\u00b0') plt.title('Projectile Trajectories for Various Angles') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Height (m)') plt.legend() plt.grid(True) plt.savefig(\"trajectories.png\") plt.show() function toggleCode() { const codeBlock = document.getElementById(\"code-block\"); const button = document.querySelector(\"button\"); if (codeBlock.style.display === \"none\") { codeBlock.style.display = \"block\"; button.textContent = \"Hide Code\"; } else { codeBlock.style.display = \"none\"; button.textContent = \"Show Code\"; } } The simulation provides a hands-on way to explore how changing parameters affects projectile motion.","title":"Computational Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#limitations-and-proposed-extensions","text":"","title":"Limitations and Proposed Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#limitations","text":"Assumes no air resistance or drag, which is unrealistic for most practical cases. Assumes constant gravitational acceleration and flat terrain. Neglects wind and lateral forces. Assumes instantaneous launch without propulsion after initial velocity.","title":"Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#proposed-extensions","text":"Incorporate drag force models (linear or quadratic) to simulate air resistance and its effect on range and trajectory. Add wind effects as lateral forces that affect horizontal displacement. Introduce terrain models with variable landing heights for more realistic conditions. Use numerical solvers (e.g., Runge-Kutta methods) to solve differential equations that do not have closed-form analytical solutions. These enhancements make the model closer to real-world physics, expanding its applicability in sports science, engineering, and astrophysics.","title":"Proposed Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Investigating the Dynamics of a Forced Damped Pendulum The forced damped pendulum serves as a powerful example in classical mechanics for studying the behavior of nonlinear dynamical systems. When a pendulum is subject to both damping (e.g., friction or air resistance) and an external periodic driving force, its motion is governed by a rich and intricate set of dynamics that go far beyond simple harmonic motion. These include resonance, quasiperiodicity, bifurcations, and deterministic chaos. By analyzing this system, we gain deeper insight into a wide array of real-world phenomena\u2014from the vibrations of mechanical structures and energy harvesting systems to signal filtering in electronic circuits and biological rhythms. This study leverages both analytical approximations and computational simulations to explore the effects of varying system parameters on the behavior of the pendulum. Theoretical Foundation Governing Equation of Motion The motion of a forced damped pendulum is governed by the nonlinear second-order differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) \\] Where: \\(\\theta(t)\\) : angular displacement, \\(b\\) : damping coefficient, \\(g\\) : gravitational acceleration, \\(L\\) : length of the pendulum, \\(A\\) : amplitude of the driving force, \\(\\omega\\) : angular frequency of the driving force. Let \\(\\omega_0^2 = \\frac{g}{L}\\) represent the natural frequency squared. Small-Angle Approximation When \\(\\theta\\) is small (i.e., \\(|\\theta| \\ll 1\\) ), we can approximate \\(\\sin\\theta \\approx \\theta\\) . The governing equation becomes linear: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This is a classic driven damped harmonic oscillator. Approximate Solution for Small-Angle Oscillations The general solution is composed of a homogeneous (transient) and a particular (steady-state) part: \\[ \\theta(t) = \\theta_{\\text{hom}}(t) + \\theta_{\\text{part}}(t) \\] Transient response: $$ \\theta_{\\text{hom}}(t) = C e^{-\\beta t} \\cos(\\omega_d t + \\phi) $$ where: \\(\\beta = \\frac{b}{2}\\) and \\(\\omega_d = \\sqrt{\\omega_0^2 - \\beta^2}\\) Steady-state response: $$ \\theta_{\\text{part}}(t) = \\Theta \\cos(\\omega t - \\delta) $$ where: $$ \\Theta = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (2\\beta\\omega)^2}}, \\quad \\tan\\delta = \\frac{2\\beta\\omega}{\\omega_0^2 - \\omega^2} $$ Resonance and Energy Implications Resonance occurs when the driving frequency approaches the system\u2019s natural frequency. For low damping: \\[ \\omega_{\\text{res}} \\approx \\sqrt{\\omega_0^2 - 2\\beta^2} \\] At this frequency, energy transfer from the driver to the system is maximized, leading to large amplitude oscillations. This phenomenon is critical in engineering, where it must be managed to avoid structural failures, and in technology, where it can be exploited for energy harvesting or frequency filtering. Analysis of Dynamics Influence of Parameters Damping coefficient ( \\(b\\) ) : High damping suppresses oscillations and chaos, while low damping allows richer dynamics. Driving amplitude ( \\(A\\) ) : Larger amplitudes can drive the system into nonlinear and even chaotic regimes. Driving frequency ( \\(\\omega\\) ) : Controls resonance. Frequencies close to \\(\\omega_0\\) produce large amplitude oscillations. Transition to Chaos As system parameters change, the pendulum exhibits a transition from: Periodic motion : Stable, repeating behavior. Quasiperiodic motion : Non-repeating but regular. Chaotic motion : Sensitive to initial conditions, irregular, and unpredictable. These behaviors are visualized through phase diagrams and Poincar\u00e9 sections. Practical Applications Energy Harvesting : Resonant mechanical oscillators in piezoelectric systems extract energy from ambient vibrations. Suspension Bridges : Oscillatory wind or traffic loads can excite resonances; damping mitigates risk. RLC Circuits : Analogous to the pendulum\u2019s equation, they exhibit similar resonance and damping effects. Biomechanics : Human gait and prosthetic limb design can be modeled as forced damped oscillators. Implementation (Python Simulation) Here's a simulation of a forced damped pendulum using typical parameters. The three visualizations are: Show Code import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters for the forced damped pendulum g = 9.81 # gravity (m/s^2) L = 1.0 # length of pendulum (m) b = 0.5 # damping coefficient A = 1.2 # driving amplitude omega = 2.0 # driving frequency T = 2 * np.pi / omega # driving period duration = 100 # total time to simulate num_points = 10000 # resolution # Differential equation for the system def pendulum_ode(t, y): theta, omega_ = y dtheta_dt = omega_ domega_dt = -b * omega_ - (g / L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Time array and initial conditions t_eval = np.linspace(0, duration, num_points) initial_conditions = [0.2, 0.0] # Solve the ODE sol = solve_ivp(pendulum_ode, [0, duration], initial_conditions, t_eval=t_eval, method='RK45') # Extract results theta = sol.y[0] omega_ = sol.y[1] time = sol.t # Compute Poincar\u00e9 section (sample at each period) poincare_times = np.arange(0, duration, T) poincare_indices = [np.abs(time - pt).argmin() for pt in poincare_times] theta_poincare = theta[poincare_indices] omega_poincare = omega_[poincare_indices] # Plotting fig, axs = plt.subplots(3, 1, figsize=(10, 12)) # Time evolution axs[0].plot(time, theta, label='\u03b8(t)') axs[0].set_title('Angular Displacement vs Time') axs[0].set_xlabel('Time (s)') axs[0].set_ylabel('\u03b8 (rad)') axs[0].grid() # Phase portrait axs[1].plot(theta, omega_, color='darkorange') axs[1].set_title('Phase Portrait') axs[1].set_xlabel('\u03b8 (rad)') axs[1].set_ylabel('\u03c9 (rad/s)') axs[1].grid() # Poincar\u00e9 section axs[2].scatter(theta_poincare, omega_poincare, color='green', s=10) axs[2].set_title('Poincar\u00e9 Section') axs[2].set_xlabel('\u03b8 (rad)') axs[2].set_ylabel('\u03c9 (rad/s)') axs[2].grid() plt.tight_layout() plt.show() function toggleCode() { const codeBlock = document.getElementById(\"code-block\"); const button = document.querySelector(\"button\"); if (codeBlock.style.display === \"none\") { codeBlock.style.display = \"block\"; button.textContent = \"Hide Code\"; } else { codeBlock.style.display = \"none\"; button.textContent = \"Show Code\"; } } Angular Displacement vs Time \u2013 shows how the angle evolves over time under periodic forcing. Illustrates the evolution of the pendulum under different forcing conditions. Phase Portrait \u2013 plots angular velocity against angle, revealing the system\u2019s dynamical structure. Displays trajectories in phase space to distinguish between periodic and chaotic regimes. Poincar\u00e9 Section \u2013 samples the system at regular intervals (every driving period) to help detect patterns. Reveals hidden structures and irregularities in motion, useful for identifying chaos. Extensions and Limitations Model Limitations: Air resistance and pivot friction are not always captured accurately by linear damping. External forces may not always be strictly periodic. Extensions: Include nonlinear or velocity-squared damping. Add stochastic (random) driving terms. Explore coupling between multiple pendulums.","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"The forced damped pendulum serves as a powerful example in classical mechanics for studying the behavior of nonlinear dynamical systems. When a pendulum is subject to both damping (e.g., friction or air resistance) and an external periodic driving force, its motion is governed by a rich and intricate set of dynamics that go far beyond simple harmonic motion. These include resonance, quasiperiodicity, bifurcations, and deterministic chaos. By analyzing this system, we gain deeper insight into a wide array of real-world phenomena\u2014from the vibrations of mechanical structures and energy harvesting systems to signal filtering in electronic circuits and biological rhythms. This study leverages both analytical approximations and computational simulations to explore the effects of varying system parameters on the behavior of the pendulum.","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#theoretical-foundation","text":"","title":"Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#governing-equation-of-motion","text":"The motion of a forced damped pendulum is governed by the nonlinear second-order differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) \\] Where: \\(\\theta(t)\\) : angular displacement, \\(b\\) : damping coefficient, \\(g\\) : gravitational acceleration, \\(L\\) : length of the pendulum, \\(A\\) : amplitude of the driving force, \\(\\omega\\) : angular frequency of the driving force. Let \\(\\omega_0^2 = \\frac{g}{L}\\) represent the natural frequency squared.","title":"Governing Equation of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"When \\(\\theta\\) is small (i.e., \\(|\\theta| \\ll 1\\) ), we can approximate \\(\\sin\\theta \\approx \\theta\\) . The governing equation becomes linear: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This is a classic driven damped harmonic oscillator.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#approximate-solution-for-small-angle-oscillations","text":"The general solution is composed of a homogeneous (transient) and a particular (steady-state) part: \\[ \\theta(t) = \\theta_{\\text{hom}}(t) + \\theta_{\\text{part}}(t) \\] Transient response: $$ \\theta_{\\text{hom}}(t) = C e^{-\\beta t} \\cos(\\omega_d t + \\phi) $$ where: \\(\\beta = \\frac{b}{2}\\) and \\(\\omega_d = \\sqrt{\\omega_0^2 - \\beta^2}\\) Steady-state response: $$ \\theta_{\\text{part}}(t) = \\Theta \\cos(\\omega t - \\delta) $$ where: $$ \\Theta = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (2\\beta\\omega)^2}}, \\quad \\tan\\delta = \\frac{2\\beta\\omega}{\\omega_0^2 - \\omega^2} $$","title":"Approximate Solution for Small-Angle Oscillations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-and-energy-implications","text":"Resonance occurs when the driving frequency approaches the system\u2019s natural frequency. For low damping: \\[ \\omega_{\\text{res}} \\approx \\sqrt{\\omega_0^2 - 2\\beta^2} \\] At this frequency, energy transfer from the driver to the system is maximized, leading to large amplitude oscillations. This phenomenon is critical in engineering, where it must be managed to avoid structural failures, and in technology, where it can be exploited for energy harvesting or frequency filtering.","title":"Resonance and Energy Implications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#analysis-of-dynamics","text":"","title":"Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#influence-of-parameters","text":"Damping coefficient ( \\(b\\) ) : High damping suppresses oscillations and chaos, while low damping allows richer dynamics. Driving amplitude ( \\(A\\) ) : Larger amplitudes can drive the system into nonlinear and even chaotic regimes. Driving frequency ( \\(\\omega\\) ) : Controls resonance. Frequencies close to \\(\\omega_0\\) produce large amplitude oscillations.","title":"Influence of Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#transition-to-chaos","text":"As system parameters change, the pendulum exhibits a transition from: Periodic motion : Stable, repeating behavior. Quasiperiodic motion : Non-repeating but regular. Chaotic motion : Sensitive to initial conditions, irregular, and unpredictable. These behaviors are visualized through phase diagrams and Poincar\u00e9 sections.","title":"Transition to Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#practical-applications","text":"Energy Harvesting : Resonant mechanical oscillators in piezoelectric systems extract energy from ambient vibrations. Suspension Bridges : Oscillatory wind or traffic loads can excite resonances; damping mitigates risk. RLC Circuits : Analogous to the pendulum\u2019s equation, they exhibit similar resonance and damping effects. Biomechanics : Human gait and prosthetic limb design can be modeled as forced damped oscillators.","title":"Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#implementation-python-simulation","text":"Here's a simulation of a forced damped pendulum using typical parameters. The three visualizations are: Show Code import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters for the forced damped pendulum g = 9.81 # gravity (m/s^2) L = 1.0 # length of pendulum (m) b = 0.5 # damping coefficient A = 1.2 # driving amplitude omega = 2.0 # driving frequency T = 2 * np.pi / omega # driving period duration = 100 # total time to simulate num_points = 10000 # resolution # Differential equation for the system def pendulum_ode(t, y): theta, omega_ = y dtheta_dt = omega_ domega_dt = -b * omega_ - (g / L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Time array and initial conditions t_eval = np.linspace(0, duration, num_points) initial_conditions = [0.2, 0.0] # Solve the ODE sol = solve_ivp(pendulum_ode, [0, duration], initial_conditions, t_eval=t_eval, method='RK45') # Extract results theta = sol.y[0] omega_ = sol.y[1] time = sol.t # Compute Poincar\u00e9 section (sample at each period) poincare_times = np.arange(0, duration, T) poincare_indices = [np.abs(time - pt).argmin() for pt in poincare_times] theta_poincare = theta[poincare_indices] omega_poincare = omega_[poincare_indices] # Plotting fig, axs = plt.subplots(3, 1, figsize=(10, 12)) # Time evolution axs[0].plot(time, theta, label='\u03b8(t)') axs[0].set_title('Angular Displacement vs Time') axs[0].set_xlabel('Time (s)') axs[0].set_ylabel('\u03b8 (rad)') axs[0].grid() # Phase portrait axs[1].plot(theta, omega_, color='darkorange') axs[1].set_title('Phase Portrait') axs[1].set_xlabel('\u03b8 (rad)') axs[1].set_ylabel('\u03c9 (rad/s)') axs[1].grid() # Poincar\u00e9 section axs[2].scatter(theta_poincare, omega_poincare, color='green', s=10) axs[2].set_title('Poincar\u00e9 Section') axs[2].set_xlabel('\u03b8 (rad)') axs[2].set_ylabel('\u03c9 (rad/s)') axs[2].grid() plt.tight_layout() plt.show() function toggleCode() { const codeBlock = document.getElementById(\"code-block\"); const button = document.querySelector(\"button\"); if (codeBlock.style.display === \"none\") { codeBlock.style.display = \"block\"; button.textContent = \"Hide Code\"; } else { codeBlock.style.display = \"none\"; button.textContent = \"Show Code\"; } } Angular Displacement vs Time \u2013 shows how the angle evolves over time under periodic forcing. Illustrates the evolution of the pendulum under different forcing conditions. Phase Portrait \u2013 plots angular velocity against angle, revealing the system\u2019s dynamical structure. Displays trajectories in phase space to distinguish between periodic and chaotic regimes. Poincar\u00e9 Section \u2013 samples the system at regular intervals (every driving period) to help detect patterns. Reveals hidden structures and irregularities in motion, useful for identifying chaos.","title":"Implementation (Python Simulation)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#extensions-and-limitations","text":"","title":"Extensions and Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#model-limitations","text":"Air resistance and pivot friction are not always captured accurately by linear damping. External forces may not always be strictly periodic.","title":"Model Limitations:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#extensions","text":"Include nonlinear or velocity-squared damping. Add stochastic (random) driving terms. Explore coupling between multiple pendulums.","title":"Extensions:"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Orbital Period and Orbital Radius The orbital period refers to the time a body takes to complete one full orbit around another object, such as the Earth orbiting the Sun or a moon orbiting a planet. This period is typically measured in units of time, such as seconds, days, or years, and depends on the mass of the central object and the distance between the two bodies. The orbital radius, on the other hand, is the average distance from the orbiting body to the center of the object it is orbiting. For circular or nearly circular orbits, it is essentially the radius of the orbit. This distance plays a crucial role in determining the orbital speed and period through Kepler\u2019s Laws and Newton\u2019s Law of Gravitation . Understanding these two properties is essential for calculating satellite trajectories, planning space missions, and studying the dynamics of planetary systems. Derivation of the Formula Consider a body of mass \\(m\\) orbiting a much larger body of mass \\(M\\) in a circular orbit of radius \\(r\\) and period \\(T\\) . Centripetal Force and Gravitational Force \\[ \\frac{G M m}{r^2} = m \\frac{v^2}{r} \\] Where: \\(G\\) is the gravitational constant \\(v\\) is the orbital speed. Canceling \\(m\\) and multiplying both sides by \\(r\\) : \\[ \\frac{GM}{r} = v^2 \\] Expressing Speed in Terms of Period The orbital speed \\(v\\) is also given by: \\[ v = \\frac{2 \\pi r}{T} \\] Substitute into the previous equation: \\[ \\frac{GM}{r} = \\left( \\frac{2\\pi r}{T} \\right)^2 \\] \\[ \\frac{GM}{r} = \\frac{4\\pi^2 r^2}{T^2} \\] Multiply both sides by \\(T^2 r\\) : \\[ GM T^2 = 4 \\pi^2 r^3 \\] Final Form: \\[ T^2 = \\frac{4 \\pi^2}{GM} r^3 \\] Astronomical Implications Determining Masses : By observing \\(T\\) and \\(r\\) , astronomers can estimate the mass \\(M\\) of the central object. Distance Measurement : If the mass is known, this law allows the calculation of the orbital radius from the period. Planetary Systems : It confirms that outer planets in our Solar System have longer periods and larger orbital radii. Real-World Examples Example 1: The Moon's Orbit Orbital radius \\(r \\approx\\) 384,400 km Period \\(T \\approx\\) 27.3 days Using Kepler's Law, this fits well with Earth's mass \\(5.972 \\times 10^{24}\\) kg. Example 2: Planetary Orbits Mars \\((T = 687\\) days, \\(r = 1.52\\) AU) Jupiter \\((T = 11.86\\) years, \\(r = 5.2\\) AU) The ratio \\(\\frac{T^2}{r^3}\\) remains nearly constant, verifying Kepler's Third Law. Computational Model (Python) We'll simulate bodies in circular orbits and verify \\(T^2 \\propto r^3\\) . import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 # gravitational constant \\(M\\) = 1.989e30 # mass of the Sun (kg) # Radii in meters (e.g., 1 AU to 10 AU) radii = np.linspace(1.5e11, 7.5e11, 10) periods = [] for r in radii: T = 2 * np.pi * np.sqrt(r**3 / (G * \\(M\\))) periods.append(T) radii_au = radii / 1.496e11 periods_yr = np.array(periods) / (60 * 60 * 24 * 365.25) # Plot T^2 vs r^3 plt.figure(figsize=(8,5)) plt.plot(radii_au**3, periods_yr**2, 'o-', label=r'$T^2 \\propto r^3$') plt.xlabel('Orbital Radius Cubed (AU^3)') plt.ylabel('Orbital Period Squared (years^2)') plt.title(\"Verification of Kepler's Third Law\") plt.grid(True) plt.legend() plt.show() Graphical Representation The graph plots \\(T^2\\) against \\(r^3\\) , and the linearity confirms the theoretical relationship. Each point corresponds to a simulated orbit at a different radius. Extension to Elliptical Orbits Kepler\u2019s Third Law also applies to elliptical orbits when using the semi-major axis \\(a\\) in place of \\(r\\) . The same relationship holds: \\[ T^2 \\propto a^3 \\] This is crucial in modeling real planetary orbits, which are slightly elliptical rather than perfectly circular. Conclusion The relationship \\(T^2 \\propto a^3\\) derived from Newtonian mechanics is a cornerstone of orbital mechanics. It allows astronomers to understand and predict the motions of celestial bodies with high precision. Whether applied to moons, planets, or artificial satellites, this principle remains a vital tool in both theoretical and applied astrophysics. The computational model and real-world examples strongly support the validity and utility of Kepler's Third Law.","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"The orbital period refers to the time a body takes to complete one full orbit around another object, such as the Earth orbiting the Sun or a moon orbiting a planet. This period is typically measured in units of time, such as seconds, days, or years, and depends on the mass of the central object and the distance between the two bodies. The orbital radius, on the other hand, is the average distance from the orbiting body to the center of the object it is orbiting. For circular or nearly circular orbits, it is essentially the radius of the orbit. This distance plays a crucial role in determining the orbital speed and period through Kepler\u2019s Laws and Newton\u2019s Law of Gravitation . Understanding these two properties is essential for calculating satellite trajectories, planning space missions, and studying the dynamics of planetary systems.","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-the-formula","text":"Consider a body of mass \\(m\\) orbiting a much larger body of mass \\(M\\) in a circular orbit of radius \\(r\\) and period \\(T\\) .","title":"Derivation of the Formula"},{"location":"1%20Physics/2%20Gravity/Problem_1/#centripetal-force-and-gravitational-force","text":"\\[ \\frac{G M m}{r^2} = m \\frac{v^2}{r} \\] Where: \\(G\\) is the gravitational constant \\(v\\) is the orbital speed. Canceling \\(m\\) and multiplying both sides by \\(r\\) : \\[ \\frac{GM}{r} = v^2 \\]","title":"Centripetal Force and Gravitational Force"},{"location":"1%20Physics/2%20Gravity/Problem_1/#expressing-speed-in-terms-of-period","text":"The orbital speed \\(v\\) is also given by: \\[ v = \\frac{2 \\pi r}{T} \\] Substitute into the previous equation: \\[ \\frac{GM}{r} = \\left( \\frac{2\\pi r}{T} \\right)^2 \\] \\[ \\frac{GM}{r} = \\frac{4\\pi^2 r^2}{T^2} \\] Multiply both sides by \\(T^2 r\\) : \\[ GM T^2 = 4 \\pi^2 r^3 \\]","title":"Expressing Speed in Terms of Period"},{"location":"1%20Physics/2%20Gravity/Problem_1/#final-form","text":"\\[ T^2 = \\frac{4 \\pi^2}{GM} r^3 \\]","title":"Final Form:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#astronomical-implications","text":"Determining Masses : By observing \\(T\\) and \\(r\\) , astronomers can estimate the mass \\(M\\) of the central object. Distance Measurement : If the mass is known, this law allows the calculation of the orbital radius from the period. Planetary Systems : It confirms that outer planets in our Solar System have longer periods and larger orbital radii.","title":"Astronomical Implications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-examples","text":"","title":"Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-1-the-moons-orbit","text":"Orbital radius \\(r \\approx\\) 384,400 km Period \\(T \\approx\\) 27.3 days Using Kepler's Law, this fits well with Earth's mass \\(5.972 \\times 10^{24}\\) kg.","title":"Example 1: The Moon's Orbit"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-2-planetary-orbits","text":"Mars \\((T = 687\\) days, \\(r = 1.52\\) AU) Jupiter \\((T = 11.86\\) years, \\(r = 5.2\\) AU) The ratio \\(\\frac{T^2}{r^3}\\) remains nearly constant, verifying Kepler's Third Law.","title":"Example 2: Planetary Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#computational-model-python","text":"We'll simulate bodies in circular orbits and verify \\(T^2 \\propto r^3\\) . import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 # gravitational constant \\(M\\) = 1.989e30 # mass of the Sun (kg) # Radii in meters (e.g., 1 AU to 10 AU) radii = np.linspace(1.5e11, 7.5e11, 10) periods = [] for r in radii: T = 2 * np.pi * np.sqrt(r**3 / (G * \\(M\\))) periods.append(T) radii_au = radii / 1.496e11 periods_yr = np.array(periods) / (60 * 60 * 24 * 365.25) # Plot T^2 vs r^3 plt.figure(figsize=(8,5)) plt.plot(radii_au**3, periods_yr**2, 'o-', label=r'$T^2 \\propto r^3$') plt.xlabel('Orbital Radius Cubed (AU^3)') plt.ylabel('Orbital Period Squared (years^2)') plt.title(\"Verification of Kepler's Third Law\") plt.grid(True) plt.legend() plt.show()","title":"Computational Model (Python)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#graphical-representation","text":"The graph plots \\(T^2\\) against \\(r^3\\) , and the linearity confirms the theoretical relationship. Each point corresponds to a simulated orbit at a different radius.","title":"Graphical Representation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extension-to-elliptical-orbits","text":"Kepler\u2019s Third Law also applies to elliptical orbits when using the semi-major axis \\(a\\) in place of \\(r\\) . The same relationship holds: \\[ T^2 \\propto a^3 \\] This is crucial in modeling real planetary orbits, which are slightly elliptical rather than perfectly circular.","title":"Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"The relationship \\(T^2 \\propto a^3\\) derived from Newtonian mechanics is a cornerstone of orbital mechanics. It allows astronomers to understand and predict the motions of celestial bodies with high precision. Whether applied to moons, planets, or artificial satellites, this principle remains a vital tool in both theoretical and applied astrophysics. The computational model and real-world examples strongly support the validity and utility of Kepler's Third Law.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Escape Velocities and Cosmic Velocities Understanding Escape Velocity is fundamental to grasping what it takes to overcome a celestial body's gravitational pull. Building on this idea, the first, second, and third cosmic velocities represent the critical speeds needed to achieve orbit, break free from a planet's gravity, and ultimately exit an entire star system. These concepts form the foundation of modern space exploration, enabling everything from satellite deployment to deep-space missions. Definitions 1. First Cosmic Velocity (Orbital Velocity) Minimum velocity required to orbit a planet near its surface in a circular path. It's the speed at which centripetal force equals gravitational force. From Newton\u2019s law of gravitation and centripetal force: \\[ \\frac{GMm}{R^2} = \\frac{mv^2}{R} \\Rightarrow v_1 = \\sqrt{\\frac{GM}{R}} \\] 2. Second Cosmic Velocity (Escape Velocity) Minimum speed required to break free from a celestial body's gravitational field without further propulsion. Total mechanical energy at the surface must be zero for escape: \\[ \\frac{1}{2}mv^2 - \\frac{GMm}{R} = 0 \\Rightarrow v_2 = \\sqrt{\\frac{2GM}{R}} \\] 3. Third Cosmic Velocity (Interstellar Velocity) Minimum velocity needed to escape the Sun\u2019s gravity starting from a planet\u2019s orbit (used for interstellar missions). Assuming solar escape velocity from orbit: \\[ v_3 = \\sqrt{2} \\cdot v_{\\text{orbital around Sun}} \\] From Earth\u2019s orbital radius and Sun\u2019s mass: \\[ v_3 \\approx \\sqrt{\\frac{2GM_\\odot}{R_{\\text{orbit}}}} \\] Or, estimated from Earth\u2019s escape speed plus solar influence: \\[ v_3 \\approx \\sqrt{2} \\cdot v_1 \\] Simulation Results Here are calculated values for Earth, Mars, and Jupiter: \ud83c\udf0d Earth 1st Cosmic (~7900 m/s) \u2013 Velocity needed to maintain a circular orbit just above Earth's surface (Low Earth Orbit). 2nd Cosmic (~11200 m/s) \u2013 The escape velocity \u2014 needed to break free from Earth\u2019s gravity without further propulsion. 3rd Cosmic (~11180 m/s) \u2013 Velocity to leave the solar system, starting from Earth\u2019s orbit \u2014 accounting for Earth\u2019s motion around the Sun. \ud83d\udd34 Mars 1st Cosmic (~3500 m/s) \u2013 Much lower orbital velocity due to Mars' smaller mass and gravity. 2nd Cosmic (~5000 m/s) \u2013 Escape velocity is also lower than Earth\u2019s. 3rd Cosmic (~4950 m/s) \u2013 Slightly less than the escape velocity again, due to Mars already orbiting the Sun at high speed. \ud83d\udfe0 Jupiter 1st Cosmic (~42200 m/s) \u2013 Very high orbital speed needed due to Jupiter's strong gravity. 2nd Cosmic (~59500 m/s) \u2013 The energy needed to escape Jupiter\u2019s gravity is massive. 3rd Cosmic (~59600 m/s) \u2013 Almost the same as the 2nd cosmic velocity \u2014 Jupiter is already moving fast in its solar orbit. Computational Model (Python) import matplotlib.pyplot as plt import numpy as np # Data bodies = ['Earth', 'Mars', 'Jupiter'] v1 = [7900, 3500, 42200] # 1st Cosmic Velocity v2 = [11200, 5000, 59500] # 2nd Cosmic Velocity v3 = [11180, 4950, 59600] # 3rd Cosmic Velocity x = np.arange(len(bodies)) # the label locations width = 0.25 # width of the bars # Plot fig, ax = plt.subplots(figsize=(10, 6)) bars1 = ax.bar(x - width, v1, width, label='1st Cosmic Velocity (Orbital)', color='orange') bars2 = ax.bar(x, v2, width, label='2nd Cosmic Velocity (Escape)', color='orangered') bars3 = ax.bar(x + width, v3, width, label='3rd Cosmic Velocity (Interstellar)', color='deeppink') # Labels and Title ax.set_ylabel('Velocity (m/s)') ax.set_title('Cosmic Velocities for Different Celestial Bodies') ax.set_xticks(x) ax.set_xticklabels(bodies) ax.legend() # Grid and Layout ax.grid(axis='y', linestyle='--', alpha=0.7) plt.tight_layout() plt.show() Importance in Space Exploration Velocity Type Relevance 1st Cosmic Launching satellites into low Earth orbit (LEO), like the ISS. 2nd Cosmic Space probes, lunar missions (Apollo), Mars rovers. 3rd Cosmic Voyager, New Horizons \u2014 missions aiming to leave the solar system. Conclusion Understanding these velocities is crucial for : Efficient fuel planning, mission architecture, propulsion system requirements, and future interplanetary and interstellar missions.","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"Understanding Escape Velocity is fundamental to grasping what it takes to overcome a celestial body's gravitational pull. Building on this idea, the first, second, and third cosmic velocities represent the critical speeds needed to achieve orbit, break free from a planet's gravity, and ultimately exit an entire star system. These concepts form the foundation of modern space exploration, enabling everything from satellite deployment to deep-space missions.","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions","text":"1. First Cosmic Velocity (Orbital Velocity) Minimum velocity required to orbit a planet near its surface in a circular path. It's the speed at which centripetal force equals gravitational force. From Newton\u2019s law of gravitation and centripetal force: \\[ \\frac{GMm}{R^2} = \\frac{mv^2}{R} \\Rightarrow v_1 = \\sqrt{\\frac{GM}{R}} \\] 2. Second Cosmic Velocity (Escape Velocity) Minimum speed required to break free from a celestial body's gravitational field without further propulsion. Total mechanical energy at the surface must be zero for escape: \\[ \\frac{1}{2}mv^2 - \\frac{GMm}{R} = 0 \\Rightarrow v_2 = \\sqrt{\\frac{2GM}{R}} \\] 3. Third Cosmic Velocity (Interstellar Velocity) Minimum velocity needed to escape the Sun\u2019s gravity starting from a planet\u2019s orbit (used for interstellar missions). Assuming solar escape velocity from orbit: \\[ v_3 = \\sqrt{2} \\cdot v_{\\text{orbital around Sun}} \\] From Earth\u2019s orbital radius and Sun\u2019s mass: \\[ v_3 \\approx \\sqrt{\\frac{2GM_\\odot}{R_{\\text{orbit}}}} \\] Or, estimated from Earth\u2019s escape speed plus solar influence: \\[ v_3 \\approx \\sqrt{2} \\cdot v_1 \\]","title":"Definitions"},{"location":"1%20Physics/2%20Gravity/Problem_2/#simulation-results","text":"Here are calculated values for Earth, Mars, and Jupiter:","title":"Simulation Results"},{"location":"1%20Physics/2%20Gravity/Problem_2/#earth","text":"1st Cosmic (~7900 m/s) \u2013 Velocity needed to maintain a circular orbit just above Earth's surface (Low Earth Orbit). 2nd Cosmic (~11200 m/s) \u2013 The escape velocity \u2014 needed to break free from Earth\u2019s gravity without further propulsion. 3rd Cosmic (~11180 m/s) \u2013 Velocity to leave the solar system, starting from Earth\u2019s orbit \u2014 accounting for Earth\u2019s motion around the Sun.","title":"\ud83c\udf0d Earth"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mars","text":"1st Cosmic (~3500 m/s) \u2013 Much lower orbital velocity due to Mars' smaller mass and gravity. 2nd Cosmic (~5000 m/s) \u2013 Escape velocity is also lower than Earth\u2019s. 3rd Cosmic (~4950 m/s) \u2013 Slightly less than the escape velocity again, due to Mars already orbiting the Sun at high speed.","title":"\ud83d\udd34 Mars"},{"location":"1%20Physics/2%20Gravity/Problem_2/#jupiter","text":"1st Cosmic (~42200 m/s) \u2013 Very high orbital speed needed due to Jupiter's strong gravity. 2nd Cosmic (~59500 m/s) \u2013 The energy needed to escape Jupiter\u2019s gravity is massive. 3rd Cosmic (~59600 m/s) \u2013 Almost the same as the 2nd cosmic velocity \u2014 Jupiter is already moving fast in its solar orbit.","title":"\ud83d\udfe0 Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#computational-model-python","text":"import matplotlib.pyplot as plt import numpy as np # Data bodies = ['Earth', 'Mars', 'Jupiter'] v1 = [7900, 3500, 42200] # 1st Cosmic Velocity v2 = [11200, 5000, 59500] # 2nd Cosmic Velocity v3 = [11180, 4950, 59600] # 3rd Cosmic Velocity x = np.arange(len(bodies)) # the label locations width = 0.25 # width of the bars # Plot fig, ax = plt.subplots(figsize=(10, 6)) bars1 = ax.bar(x - width, v1, width, label='1st Cosmic Velocity (Orbital)', color='orange') bars2 = ax.bar(x, v2, width, label='2nd Cosmic Velocity (Escape)', color='orangered') bars3 = ax.bar(x + width, v3, width, label='3rd Cosmic Velocity (Interstellar)', color='deeppink') # Labels and Title ax.set_ylabel('Velocity (m/s)') ax.set_title('Cosmic Velocities for Different Celestial Bodies') ax.set_xticks(x) ax.set_xticklabels(bodies) ax.legend() # Grid and Layout ax.grid(axis='y', linestyle='--', alpha=0.7) plt.tight_layout() plt.show()","title":"Computational Model (Python)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#importance-in-space-exploration","text":"Velocity Type Relevance 1st Cosmic Launching satellites into low Earth orbit (LEO), like the ISS. 2nd Cosmic Space probes, lunar missions (Apollo), Mars rovers. 3rd Cosmic Voyager, New Horizons \u2014 missions aiming to leave the solar system.","title":"Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#conclusion","text":"Understanding these velocities is crucial for : Efficient fuel planning, mission architecture, propulsion system requirements, and future interplanetary and interstellar missions.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Trajectories of a Freely Released Payload Near Earth Orbital Motion Analysis When a payload is released near Earth, its subsequent path is governed by the laws of gravitational motion. Depending on its velocity and direction at the moment of release, the payload may follow a parabolic , elliptical , circular , or hyperbolic trajectory . These paths are crucial to understanding outcomes such as orbital insertion , reentry , or escape from Earth's gravitational influence. This presentation is an analytical and numerical study of these trajectories, supported by simulations that visualize the motion under various initial conditions. Theoretical Background Newton's Law of Universal Gravitation The gravitational force exerted by Earth on a payload of mass \\(m\\) is: \\[ F = \\frac{G M_E m}{r^2} \\] Where: \\(G = 6.67430 \\times 10^{-11}\\) N\u00b7m\u00b2/kg\u00b2 (gravitational constant) \\(M_E = 5.972 \\times 10^{24}\\) kg (mass of Earth) \\(r\\) = distance from Earth\u2019s center Equation of Motion The payload's acceleration \\(\\vec{a}\\) due to gravity is: \\[ \\vec{a} = -\\frac{G M_E}{r^3} \\vec{r} \\] This leads to a second-order differential equation for numerical integration. Orbital Shapes The total mechanical energy \\(E\\) of the system defines the trajectory type: Elliptical orbit: \\(E < 0\\) Parabolic escape: \\(E = 0\\) Hyperbolic escape: \\(E > 0\\) Circular orbit (special case of ellipse): constant radius \\[ E = \\frac{1}{2}mv^2 - \\frac{G M_E m}{r} \\] Numerical Analysis and Simulation Initial Conditions The payload is released from a point \\(\\vec{r}_0\\) (typically above Earth\u2019s surface) with a velocity \\(\\vec{v}_0\\) . Varying \\(\\vec{v}_0\\) and its direction simulates different outcomes. Numerical Method: Runge-Kutta (RK4) The fourth-order Runge-Kutta method is used to solve the equations of motion: \\[ \\mathbf{r}_{n+1}, \\mathbf{v}_{n+1} = f(\\mathbf{r}_n, \\mathbf{v}_n, \\Delta t) \\] A time step \\(\\Delta t\\) is chosen small enough to ensure accuracy. Python Implementation Overview def simulate_trajectory(r0, v0, t_max=6000, dt=1): r, v = r0, v0 trajectory = [r.copy()] for _ in range(int(t_max/dt)): r, v = rk4(r, v, dt) trajectory.append(r.copy()) if np.linalg.norm(r) < R_earth: break return np.array(trajectory) # Example r0 = np.array([R_earth + 200e3, 0]) v0 = np.array([0, 7800]) trajectory = simulate_trajectory(r0, v0) plt.plot(trajectory[:,0], trajectory[:,1]) circle = plt.Circle((0, 0), R_earth, color='blue', alpha=0.3) plt.gca().add_artist(circle) plt.axis('equal') plt.title(\"Payload Trajectory Near Earth\") plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.grid() plt.show() Simulation Cases Orbital Simulation Orbital Simulation Initial Speed (m/s): 3000 const G = 6.67430e-11; const M = 5.972e24; const R_earth = 6371e3; const altitude = 200e3; const dt = 1.0; const t_max = 10000; function acceleration(r) { const norm = Math.sqrt(r[0]**2 + r[1]**2); return [-G * M * r[0] / norm**3, -G * M * r[1] / norm**3]; } function rk4_step(r, v, dt) { const a1 = acceleration(r); const k1r = [v[0] * dt, v[1] * dt]; const k1v = [a1[0] * dt, a1[1] * dt]; const r2 = [r[0] + 0.5 * k1r[0], r[1] + 0.5 * k1r[1]]; const v2 = [v[0] + 0.5 * k1v[0], v[1] + 0.5 * k1v[1]]; const a2 = acceleration(r2); const k2r = [v2[0] * dt, v2[1] * dt]; const k2v = [a2[0] * dt, a2[1] * dt]; const r3 = [r[0] + 0.5 * k2r[0], r[1] + 0.5 * k2r[1]]; const v3 = [v[0] + 0.5 * k2v[0], v[1] + 0.5 * k2v[1]]; const a3 = acceleration(r3); const k3r = [v3[0] * dt, v3[1] * dt]; const k3v = [a3[0] * dt, a3[1] * dt]; const r4 = [r[0] + k3r[0], r[1] + k3r[1]]; const v4 = [v[0] + k3v[0], v[1] + k3v[1]]; const a4 = acceleration(r4); const k4r = [v4[0] * dt, v4[1] * dt]; const k4v = [a4[0] * dt, a4[1] * dt]; const r_next = [ r[0] + (k1r[0] + 2*k2r[0] + 2*k3r[0] + k4r[0]) / 6, r[1] + (k1r[1] + 2*k2r[1] + 2*k3r[1] + k4r[1]) / 6 ]; const v_next = [ v[0] + (k1v[0] + 2*k2v[0] + 2*k3v[0] + k4v[0]) / 6, v[1] + (k1v[1] + 2*k2v[1] + 2*k3v[1] + k4v[1]) / 6 ]; return [r_next, v_next]; } function simulate(initial_speed) { let r = [R_earth + altitude, 0]; let v = [0, initial_speed]; let x = [], y = []; for (let t = 0; t < t_max; t += dt) { [r, v] = rk4_step(r, v, dt); if (Math.hypot(r[0], r[1]) < R_earth) break; x.push(r[0]); y.push(r[1]); } const earth = { type: \"scatter\", x: [0], y: [0], mode: \"markers\", marker: { size: R_earth / 100000, color: \"blue\", opacity: 0.5 }, name: \"Earth\" }; const orbit = { type: \"scatter\", x: x, y: y, mode: \"lines\", line: { color: \"red\" }, name: `Speed: ${initial_speed} m/s` }; const layout = { title: `Orbital Path for Initial Speed: ${initial_speed} m/s`, xaxis: { scaleanchor: \"y\", title: \"x (m)\" }, yaxis: { title: \"y (m)\" }, showlegend: true }; Plotly.newPlot(\"plot\", [earth, orbit], layout); } const slider = document.getElementById(\"speedSlider\"); const speedVal = document.getElementById(\"speedValue\"); slider.addEventListener(\"input\", () => { const speed = parseFloat(slider.value); speedVal.textContent = speed; simulate(speed); }); simulate(parseFloat(slider.value)); Case 1: Suborbital Reentry - Initial altitude: 200 km - Initial speed: 3,000 m/s (horizontal) - Result: Elliptical path intersecting Earth \u2192 reentry Case 2: Stable Orbit - Initial speed: ~7,800 m/s - Result: Circular orbit at 200 km altitude Case 3: Escape Trajectory - Initial speed: >11,200 m/s (escape velocity) - Result: Hyperbolic trajectory Orbital Insertion, Reentry, and Escape Orbital Insertion A payload must achieve a tangential velocity of: \\[ v_c = \\sqrt{\\frac{G M_E}{r}} \\] This ensures centripetal force equals gravitational pull, leading to a circular orbit. Reentry If \\(v < v_c\\) , the trajectory is elliptical with perigee within Earth's atmosphere, causing atmospheric drag and reentry. Escape If \\(v \\geq v_{\\text{esc}} = \\sqrt{\\frac{2 G M_E}{r}}\\) , the object escapes Earth's gravitational field. Real-World Applications Satellite Deployment : Accurate velocity ensures correct orbit. Space Mission Planning : Trajectory types determine fuel needs and mission profiles. Planetary Exploration : Gravity assists and escape trajectories are used to reach other planets. Visualization Tool The simulation tool plots trajectories using matplotlib or an interactive JavaScript plot (e.g., Plotly) to dynamically observe how initial speed affects the path. Conclusion By applying fundamental physics and numerical modeling, we\u2019ve shown how the trajectory of a released payload is determined by initial conditions. This study highlights critical concepts in spaceflight mechanics and offers a practical tool for visualizing and planning near-Earth missions.","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#orbital-motion-analysis","text":"When a payload is released near Earth, its subsequent path is governed by the laws of gravitational motion. Depending on its velocity and direction at the moment of release, the payload may follow a parabolic , elliptical , circular , or hyperbolic trajectory . These paths are crucial to understanding outcomes such as orbital insertion , reentry , or escape from Earth's gravitational influence. This presentation is an analytical and numerical study of these trajectories, supported by simulations that visualize the motion under various initial conditions.","title":"Orbital Motion Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_3/#theoretical-background","text":"","title":"Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_3/#newtons-law-of-universal-gravitation","text":"The gravitational force exerted by Earth on a payload of mass \\(m\\) is: \\[ F = \\frac{G M_E m}{r^2} \\] Where: \\(G = 6.67430 \\times 10^{-11}\\) N\u00b7m\u00b2/kg\u00b2 (gravitational constant) \\(M_E = 5.972 \\times 10^{24}\\) kg (mass of Earth) \\(r\\) = distance from Earth\u2019s center","title":"Newton's Law of Universal Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#equation-of-motion","text":"The payload's acceleration \\(\\vec{a}\\) due to gravity is: \\[ \\vec{a} = -\\frac{G M_E}{r^3} \\vec{r} \\] This leads to a second-order differential equation for numerical integration.","title":"Equation of Motion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#orbital-shapes","text":"The total mechanical energy \\(E\\) of the system defines the trajectory type: Elliptical orbit: \\(E < 0\\) Parabolic escape: \\(E = 0\\) Hyperbolic escape: \\(E > 0\\) Circular orbit (special case of ellipse): constant radius \\[ E = \\frac{1}{2}mv^2 - \\frac{G M_E m}{r} \\]","title":"Orbital Shapes"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-analysis-and-simulation","text":"","title":"Numerical Analysis and Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#initial-conditions","text":"The payload is released from a point \\(\\vec{r}_0\\) (typically above Earth\u2019s surface) with a velocity \\(\\vec{v}_0\\) . Varying \\(\\vec{v}_0\\) and its direction simulates different outcomes.","title":"Initial Conditions"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-method-runge-kutta-rk4","text":"The fourth-order Runge-Kutta method is used to solve the equations of motion: \\[ \\mathbf{r}_{n+1}, \\mathbf{v}_{n+1} = f(\\mathbf{r}_n, \\mathbf{v}_n, \\Delta t) \\] A time step \\(\\Delta t\\) is chosen small enough to ensure accuracy.","title":"Numerical Method: Runge-Kutta (RK4)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-implementation-overview","text":"def simulate_trajectory(r0, v0, t_max=6000, dt=1): r, v = r0, v0 trajectory = [r.copy()] for _ in range(int(t_max/dt)): r, v = rk4(r, v, dt) trajectory.append(r.copy()) if np.linalg.norm(r) < R_earth: break return np.array(trajectory) # Example r0 = np.array([R_earth + 200e3, 0]) v0 = np.array([0, 7800]) trajectory = simulate_trajectory(r0, v0) plt.plot(trajectory[:,0], trajectory[:,1]) circle = plt.Circle((0, 0), R_earth, color='blue', alpha=0.3) plt.gca().add_artist(circle) plt.axis('equal') plt.title(\"Payload Trajectory Near Earth\") plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.grid() plt.show()","title":"Python Implementation Overview"},{"location":"1%20Physics/2%20Gravity/Problem_3/#simulation-cases","text":"Orbital Simulation","title":"Simulation Cases"},{"location":"1%20Physics/2%20Gravity/Problem_3/#orbital-insertion-reentry-and-escape","text":"","title":"Orbital Insertion, Reentry, and Escape"},{"location":"1%20Physics/2%20Gravity/Problem_3/#orbital-insertion","text":"A payload must achieve a tangential velocity of: \\[ v_c = \\sqrt{\\frac{G M_E}{r}} \\] This ensures centripetal force equals gravitational pull, leading to a circular orbit.","title":"Orbital Insertion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#reentry","text":"If \\(v < v_c\\) , the trajectory is elliptical with perigee within Earth's atmosphere, causing atmospheric drag and reentry.","title":"Reentry"},{"location":"1%20Physics/2%20Gravity/Problem_3/#escape","text":"If \\(v \\geq v_{\\text{esc}} = \\sqrt{\\frac{2 G M_E}{r}}\\) , the object escapes Earth's gravitational field.","title":"Escape"},{"location":"1%20Physics/2%20Gravity/Problem_3/#real-world-applications","text":"Satellite Deployment : Accurate velocity ensures correct orbit. Space Mission Planning : Trajectory types determine fuel needs and mission profiles. Planetary Exploration : Gravity assists and escape trajectories are used to reach other planets.","title":"Real-World Applications"},{"location":"1%20Physics/2%20Gravity/Problem_3/#visualization-tool","text":"The simulation tool plots trajectories using matplotlib or an interactive JavaScript plot (e.g., Plotly) to dynamically observe how initial speed affects the path.","title":"Visualization Tool"},{"location":"1%20Physics/2%20Gravity/Problem_3/#conclusion","text":"By applying fundamental physics and numerical modeling, we\u2019ve shown how the trajectory of a released payload is determined by initial conditions. This study highlights critical concepts in spaceflight mechanics and offers a practical tool for visualizing and planning near-Earth missions.","title":"Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Interference Patterns on a Water Surface Wave interference is a fundamental phenomenon observed when two or more wave sources interact. On a water surface, when multiple point sources emit waves, the resulting surface displacement is determined by the superposition of individual wave contributions. This presentation focuses on simulating and analyzing the interference patterns that emerge when point sources are positioned at the vertices of a regular polygon. Mathematical Model The displacement \\(\\eta(x, y, t)\\) at a point \\((x, y)\\) and time \\(t\\) due to a single wave source located at \\((x_0, y_0)\\) is given by: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos(kr - \\omega t + \\phi) \\] Where: \\(\\eta(x, y, t)\\) : Water surface displacement at point \\((x, y)\\) and time \\(t\\) \\(A\\) : Amplitude of the wave \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) : Distance from the source \\(k = \\frac{2\\pi}{\\lambda}\\) : Wave number (wavelength \\(\\lambda\\) ) \\(\\omega = 2\\pi f\\) : Angular frequency (frequency \\(f\\) ) \\(\\phi\\) : Initial phase (set to 0 in this simulation) Superposition Principle For \\(N\\) point sources, the net displacement is: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] For this, we will choose Square as our polygon. Source Positions for Square (side length \\(L = 4\\) ): \\(S_1 = (-2, 2)\\) \\(S_2 = (2, 2)\\) \\(S_3 = (2, -2)\\) \\(S_4 = (-2, -2)\\) Individual Wave Equations: \\[ \\begin{aligned} \\eta(x, y, t) &= \\frac{1}{\\sqrt{(x+2)^2 + (y-2)^2}} \\cdot A \\cos\\left(k \\sqrt{(x+2)^2 + (y-2)^2} - \\omega t + \\phi \\right) \\\\ \\end{aligned} \\] Superposition: The total wave displacement is: \\[ \\eta_{\\text{sum}}(x, y, t) = \\eta_1(x, y, t) + \\eta_2(x, y, t) + \\eta_3(x, y, t) + \\eta_4(x, y, t) \\] Visualization (Python) import numpy as np import matplotlib.pyplot as plt # Wave parameters A = 1 # Amplitude wavelength = 2 # Wavelength frequency = 1 # Frequency (Hz) k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi * frequency # Angular frequency phi = 0 # Initial phase t = 0 # Time snapshot # Define square vertices (L = 4) sources = [ (-2, 2), # S1 ( 2, 2), # S2 ( 2, -2), # S3 (-2, -2) # S4 ] # Create spatial grid x = np.linspace(-10, 10, 500) y = np.linspace(-10, 10, 500) X, Y = np.meshgrid(x, y) # Calculate wave displacement from each source eta_individual = [] for (x0, y0) in sources: R = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 # Avoid division by zero eta = A / np.sqrt(R) * np.cos(k * R - omega * t + phi) eta_individual.append(eta) # Plot individual waves fig, axs = plt.subplots(2, 2, figsize=(14, 12)) titles = [\"Wave from S1 (-2, 2)\", \"Wave from S2 (2, 2)\", \"Wave from S3 (2, -2)\", \"Wave from S4 (-2, -2)\"] for i, ax in enumerate(axs.flat): c = ax.contourf(X, Y, eta_individual[i], levels=100, cmap='RdBu') fig.colorbar(c, ax=ax) ax.set_title(titles[i]) ax.set_xlabel('x') ax.set_ylabel('y') ax.set_aspect('equal') plt.tight_layout() plt.show() # Superposition of all waves eta_sum = np.sum(eta_individual, axis=0) # Plot superposition result plt.figure(figsize=(10, 8)) contour = plt.contourf(X, Y, eta_sum, levels=100, cmap='RdBu') plt.colorbar(contour, label='Total Displacement \u03b7(x, y, t)') plt.title('Superposition of Waves from Square Configuration') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.grid(True) plt.tight_layout() plt.show() Individual Wave Patterns \u2013 Each subplot shows the displacement field generated by one of the four point sources located at the square's corners. Superposition of Waves \u2013 This plot shows the total wave pattern resulting from the interference of all four waves. You can observe areas of: Constructive interference (bright regions): where wave crests meet crests. Destructive interference (dark regions): where crests meet troughs and cancel out. A fundamental concept in physics, particularly in the study of waves and oscillations, is the Superposition Principle . It states that when multiple wave sources interact with a medium, the resulting effect (such as displacement, pressure, or electric field) at any point in space and time is the sum of the individual effects from each source. This principle holds true under conditions where the waves do not permanently alter one another's behavior (i.e., no non-linear effects occur). To examine the resulting displacement as a function of position and time in the context of interference, we consider how waves from multiple sources (vertices of a regular polygon) interact. The displacement at any point is the sum of the displacements from each individual source, in accordance with the Superposition Principle.","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"Wave interference is a fundamental phenomenon observed when two or more wave sources interact. On a water surface, when multiple point sources emit waves, the resulting surface displacement is determined by the superposition of individual wave contributions. This presentation focuses on simulating and analyzing the interference patterns that emerge when point sources are positioned at the vertices of a regular polygon.","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#mathematical-model","text":"The displacement \\(\\eta(x, y, t)\\) at a point \\((x, y)\\) and time \\(t\\) due to a single wave source located at \\((x_0, y_0)\\) is given by: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos(kr - \\omega t + \\phi) \\] Where: \\(\\eta(x, y, t)\\) : Water surface displacement at point \\((x, y)\\) and time \\(t\\) \\(A\\) : Amplitude of the wave \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) : Distance from the source \\(k = \\frac{2\\pi}{\\lambda}\\) : Wave number (wavelength \\(\\lambda\\) ) \\(\\omega = 2\\pi f\\) : Angular frequency (frequency \\(f\\) ) \\(\\phi\\) : Initial phase (set to 0 in this simulation)","title":"Mathematical Model"},{"location":"1%20Physics/3%20Waves/Problem_1/#superposition-principle","text":"For \\(N\\) point sources, the net displacement is: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] For this, we will choose Square as our polygon. Source Positions for Square (side length \\(L = 4\\) ): \\(S_1 = (-2, 2)\\) \\(S_2 = (2, 2)\\) \\(S_3 = (2, -2)\\) \\(S_4 = (-2, -2)\\) Individual Wave Equations: \\[ \\begin{aligned} \\eta(x, y, t) &= \\frac{1}{\\sqrt{(x+2)^2 + (y-2)^2}} \\cdot A \\cos\\left(k \\sqrt{(x+2)^2 + (y-2)^2} - \\omega t + \\phi \\right) \\\\ \\end{aligned} \\] Superposition: The total wave displacement is: \\[ \\eta_{\\text{sum}}(x, y, t) = \\eta_1(x, y, t) + \\eta_2(x, y, t) + \\eta_3(x, y, t) + \\eta_4(x, y, t) \\]","title":"Superposition Principle"},{"location":"1%20Physics/3%20Waves/Problem_1/#visualization-python","text":"import numpy as np import matplotlib.pyplot as plt # Wave parameters A = 1 # Amplitude wavelength = 2 # Wavelength frequency = 1 # Frequency (Hz) k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi * frequency # Angular frequency phi = 0 # Initial phase t = 0 # Time snapshot # Define square vertices (L = 4) sources = [ (-2, 2), # S1 ( 2, 2), # S2 ( 2, -2), # S3 (-2, -2) # S4 ] # Create spatial grid x = np.linspace(-10, 10, 500) y = np.linspace(-10, 10, 500) X, Y = np.meshgrid(x, y) # Calculate wave displacement from each source eta_individual = [] for (x0, y0) in sources: R = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 # Avoid division by zero eta = A / np.sqrt(R) * np.cos(k * R - omega * t + phi) eta_individual.append(eta) # Plot individual waves fig, axs = plt.subplots(2, 2, figsize=(14, 12)) titles = [\"Wave from S1 (-2, 2)\", \"Wave from S2 (2, 2)\", \"Wave from S3 (2, -2)\", \"Wave from S4 (-2, -2)\"] for i, ax in enumerate(axs.flat): c = ax.contourf(X, Y, eta_individual[i], levels=100, cmap='RdBu') fig.colorbar(c, ax=ax) ax.set_title(titles[i]) ax.set_xlabel('x') ax.set_ylabel('y') ax.set_aspect('equal') plt.tight_layout() plt.show() # Superposition of all waves eta_sum = np.sum(eta_individual, axis=0) # Plot superposition result plt.figure(figsize=(10, 8)) contour = plt.contourf(X, Y, eta_sum, levels=100, cmap='RdBu') plt.colorbar(contour, label='Total Displacement \u03b7(x, y, t)') plt.title('Superposition of Waves from Square Configuration') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.grid(True) plt.tight_layout() plt.show() Individual Wave Patterns \u2013 Each subplot shows the displacement field generated by one of the four point sources located at the square's corners. Superposition of Waves \u2013 This plot shows the total wave pattern resulting from the interference of all four waves. You can observe areas of: Constructive interference (bright regions): where wave crests meet crests. Destructive interference (dark regions): where crests meet troughs and cancel out. A fundamental concept in physics, particularly in the study of waves and oscillations, is the Superposition Principle . It states that when multiple wave sources interact with a medium, the resulting effect (such as displacement, pressure, or electric field) at any point in space and time is the sum of the individual effects from each source. This principle holds true under conditions where the waves do not permanently alter one another's behavior (i.e., no non-linear effects occur). To examine the resulting displacement as a function of position and time in the context of interference, we consider how waves from multiple sources (vertices of a regular polygon) interact. The displacement at any point is the sum of the displacements from each individual source, in accordance with the Superposition Principle.","title":"Visualization (Python)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Simulating the effects of the Lorentz Force The Lorentz force , expressed as \\[\\vec{F} = q\\vec{E} + q\\vec{v} \\times \\vec{B}\\] governs the behavior of charged particles in the presence of electric and magnetic fields. It is a cornerstone concept in plasma physics , astrophysics , and particle accelerator technology . Through simulation, we can gain a visual and intuitive understanding of how charged particles move under the influence of these fields. Exploration of Applications Key Systems: Particle Accelerators : Control and acceleration of particles using electric/magnetic fields. Mass Spectrometers : Use magnetic deflection to separate particles by mass-to-charge ratio. Plasma Confinement Devices : Such as tokamaks, which rely on magnetic fields to trap hot plasma. Field Relevance: Electric Fields \\(\\vec{E}\\) : Accelerate particles. Magnetic Fields \\(\\vec{B}\\) : Change direction, creating circular or helical motion. Crossed fields can induce drift velocities and lead to phenomena like \\(\\vec{E} \\times \\vec{B}\\) drift. Simulating Particle Motion Numerically simulate the motion of a charged particle under various electromagnetic field configurations. Simulation Scenarios: Expect circular motion (if velocity is perpendicular to \\(\\vec{B}\\) ) or helical (if there's a component along \\(\\vec{B}\\) ). Demonstrates cyclotron motion and introduces the concept of Larmor radius and cyclotron frequency . Non-trivial motion\u2014often helical with drift. Depending on vector orientation, the particle can accelerate, spiral, or follow curved paths. Produces a drift velocity : \\(\\vec{v}_{\\text{drift}} = \\frac{\\vec{E} \\times \\vec{B}}{B^2}\\) Important for magnetron motion and behavior in Hall effect . Parameter Exploration Field Strength (E and B): - The strength of the magnetic field B will directly impact the radius of the motion of the particle. A stronger B leads to a smaller radius of motion. - The electric field E , if present, could affect the overall trajectory and cause the particle to deviate from a perfect circular path. Initial Particle Velocity (V): - The velocity of the particle will affect the speed at which the particle moves in its path. The initial velocity should be broken down into components. If the velocity is perpendicular to the magnetic field, the particle will undergo circular motion. If there\u2019s a component of velocity parallel to the magnetic field, the motion will become helical. Charge and Mass of the Particle (q and m): - The charge q affects the force exerted on the particle by the magnetic field. A greater charge leads to a larger Lorentz force, influencing the radius of the motion. - The mass m of the particle determines the inertia of the particle, and thus, a heavier particle will have a larger radius of motion under the same field strength and velocity. Suggested Variations to Try Parameter Try Changing From Expected Effect \\(\\vec{B}\\) \\([0, 0, 1] \\rightarrow [0, 0, 2]\\) Tighter spirals \\(\\vec{E}\\) \\([0.5, 0, 0] \\rightarrow [0, 0, 1]\\) Helical \u2192 Accelerated spiral \\(\\vec{v}_0\\) \\([1, 0, 0] \\rightarrow [0, 0, 1]\\) Circular \u2192 Linear motion \\(q\\) \\(1 \\rightarrow -1\\) Reverse rotation direction \\(m\\) \\(1 \\rightarrow 0.1\\) Faster spirals (lighter particle) const sliderDefs = [ { id: 'q', label: 'Charge (q)', min: -2, max: 2, step: 0.1, value: 1 }, { id: 'm', label: 'Mass (m)', min: 0.1, max: 5, step: 0.1, value: 1 }, { id: 'Ex', label: 'E_x', min: -2, max: 2, step: 0.1, value: 0 }, { id: 'Ey', label: 'E_y', min: -2, max: 2, step: 0.1, value: 0 }, { id: 'Ez', label: 'E_z', min: -2, max: 2, step: 0.1, value: 0 }, { id: 'Bx', label: 'B_x', min: -2, max: 2, step: 0.1, value: 0 }, { id: 'By', label: 'B_y', min: -2, max: 2, step: 0.1, value: 0 }, { id: 'Bz', label: 'B_z', min: -2, max: 2, step: 0.1, value: 1 }, { id: 'vx', label: 'v_x', min: -2, max: 2, step: 0.1, value: 1 }, { id: 'vy', label: 'v_y', min: -2, max: 2, step: 0.1, value: 0 }, { id: 'vz', label: 'v_z', min: -2, max: 2, step: 0.1, value: 0 } ]; const sliders = {}; const slidersDiv = document.getElementById('sliders'); sliderDefs.forEach(def => { const wrapper = document.createElement('div'); wrapper.className = 'slider'; const label = document.createElement('label'); label.innerText = def.label; const input = document.createElement('input'); input.type = 'range'; input.min = def.min; input.max = def.max; input.step = def.step; input.value = def.value; input.id = def.id; const valueDisplay = document.createElement('span'); valueDisplay.innerText = ` ${input.value}`; input.oninput = () => { valueDisplay.innerText = ` ${input.value}`; plotTrajectory(); // update on slider change }; wrapper.appendChild(label); wrapper.appendChild(input); wrapper.appendChild(valueDisplay); slidersDiv.appendChild(wrapper); sliders[def.id] = input; }); function simulateParticle(q, m, E, B, v0, r0 = [0, 0, 0], dt = 0.01, steps = 1000) { let r = Array(steps).fill().map(() => [0, 0, 0]); let v = Array(steps).fill().map(() => [0, 0, 0]); r[0] = [...r0]; v[0] = [...v0]; const cross = (a, b) => [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ]; for (let i = 1; i < steps; i++) { const crossVB = cross(v[i - 1], B); const F = E.map((Ei, j) => q * (Ei + crossVB[j])); const a = F.map(f => f / m); v[i] = v[i - 1].map((vi, j) => vi + a[j] * dt); r[i] = r[i - 1].map((ri, j) => ri + v[i][j] * dt); } return r; } function plotTrajectory() { const q = parseFloat(sliders.q.value); const m = parseFloat(sliders.m.value); const E = [parseFloat(sliders.Ex.value), parseFloat(sliders.Ey.value), parseFloat(sliders.Ez.value)]; const B = [parseFloat(sliders.Bx.value), parseFloat(sliders.By.value), parseFloat(sliders.Bz.value)]; const v0 = [parseFloat(sliders.vx.value), parseFloat(sliders.vy.value), parseFloat(sliders.vz.value)]; const r = simulateParticle(q, m, E, B, v0); const x = r.map(p => p[0]); const y = r.map(p => p[1]); const z = r.map(p => p[2]); const trace = { x, y, z, type: 'scatter3d', mode: 'lines', name: 'Trajectory', line: { width: 4 } }; const start = { x: [x[0]], y: [y[0]], z: [z[0]], type: 'scatter3d', mode: 'markers', marker: { size: 5, color: 'green' }, name: 'Start' }; const end = { x: [x[x.length - 1]], y: [y[y.length - 1]], z: [z[z.length - 1]], type: 'scatter3d', mode: 'markers', marker: { size: 5, color: 'red' }, name: 'End' }; const layout = { scene: { xaxis: { title: 'X' }, yaxis: { title: 'Y' }, zaxis: { title: 'Z' } }, margin: { l: 0, r: 0, t: 40, b: 0 } }; Plotly.newPlot('plot', [trace, start, end], layout); } plotTrajectory(); // initial plot Field Strengths ( \\(\\vec{E}, \\vec{B}\\) ) Stronger \\(\\vec{B}\\) \u2192 tighter spirals (smaller radius, faster cycles) Stronger \\(\\vec{E}\\) \u2192 more acceleration/drift Initial Velocity ( \\(\\vec{v}_0\\) ) Controls direction and shape of trajectory Component perpendicular to \\(\\vec{B}\\) \u2192 circular motion Component parallel to \\(\\vec{B}\\) \u2192 helical motion Charge ( \\(q\\) ) and Mass ( \\(m\\) ) Affects acceleration: $$ \\vec{a} = \\frac{q}{m} \\left( \\vec{E} + \\vec{v} \\times \\vec{B} \\right) $$ Heavier particles \u2192 move more slowly, spiral wider By varying field strengths, initial velocities, charge, and mass, we observe: Circular or helical motion under magnetic fields Acceleration or drift under electric fields Trajectory shape and speed heavily influenced by \\(\\frac{q}{m}\\) Direction reversal when charge flips Visualization Show particle motion under various field configurations using clear, labeled plots . Emphasize key features such as: Larmor radius : Radius of circular motion in a magnetic field Drift velocity : Constant velocity perpendicular to both \\(\\vec{E}\\) and \\(\\vec{B}\\) Larmor Radius The radius of circular motion in a magnetic field: \\[ r_L = \\frac{m v_\\perp}{|q| B} \\] \\(v_\\perp\\) : component of velocity perpendicular to \\(\\vec{B}\\) \\(B\\) : magnetic field magnitude \\(q\\) : particle charge \\(m\\) : particle mass Drift Velocity (for crossed \\(\\vec{E} \\times \\vec{B}\\) fields): \\[ \\vec{v}_d = \\frac{\\vec{E} \\times \\vec{B}}{B^2} \\] This velocity is independent of charge and mass Direction is perpendicular to both \\(\\vec{E}\\) and \\(\\vec{B}\\) 2D Plot (e.g., x-y plane): Shows circular motion plus drift Larmor radius indicated as a dashed circle Drift velocity shown with an arrow 3D Plot : Displays full trajectory (helical or linear drift) Vector arrows for \\(\\vec{E}\\) and \\(\\vec{B}\\) for reference Visualizes how fields influence particle path in space Visualization Summary A charged particle follows a helical or drift path depending on the field configuration Larmor radius determines the size of the circular motion in a magnetic field In crossed \\(\\vec{E} \\times \\vec{B}\\) fields, the particle drifts at constant speed perpendicular to both fields These visuals help explain energy transfer and particle control in devices like mass spectrometers and plasma traps","title":"Simulating the effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"The Lorentz force , expressed as \\[\\vec{F} = q\\vec{E} + q\\vec{v} \\times \\vec{B}\\] governs the behavior of charged particles in the presence of electric and magnetic fields. It is a cornerstone concept in plasma physics , astrophysics , and particle accelerator technology . Through simulation, we can gain a visual and intuitive understanding of how charged particles move under the influence of these fields.","title":"Simulating the effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#exploration-of-applications","text":"Key Systems: Particle Accelerators : Control and acceleration of particles using electric/magnetic fields. Mass Spectrometers : Use magnetic deflection to separate particles by mass-to-charge ratio. Plasma Confinement Devices : Such as tokamaks, which rely on magnetic fields to trap hot plasma. Field Relevance: Electric Fields \\(\\vec{E}\\) : Accelerate particles. Magnetic Fields \\(\\vec{B}\\) : Change direction, creating circular or helical motion. Crossed fields can induce drift velocities and lead to phenomena like \\(\\vec{E} \\times \\vec{B}\\) drift.","title":"Exploration of Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-particle-motion","text":"Numerically simulate the motion of a charged particle under various electromagnetic field configurations. Simulation Scenarios: Expect circular motion (if velocity is perpendicular to \\(\\vec{B}\\) ) or helical (if there's a component along \\(\\vec{B}\\) ). Demonstrates cyclotron motion and introduces the concept of Larmor radius and cyclotron frequency . Non-trivial motion\u2014often helical with drift. Depending on vector orientation, the particle can accelerate, spiral, or follow curved paths. Produces a drift velocity : \\(\\vec{v}_{\\text{drift}} = \\frac{\\vec{E} \\times \\vec{B}}{B^2}\\) Important for magnetron motion and behavior in Hall effect .","title":"Simulating Particle Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#parameter-exploration","text":"Field Strength (E and B): - The strength of the magnetic field B will directly impact the radius of the motion of the particle. A stronger B leads to a smaller radius of motion. - The electric field E , if present, could affect the overall trajectory and cause the particle to deviate from a perfect circular path. Initial Particle Velocity (V): - The velocity of the particle will affect the speed at which the particle moves in its path. The initial velocity should be broken down into components. If the velocity is perpendicular to the magnetic field, the particle will undergo circular motion. If there\u2019s a component of velocity parallel to the magnetic field, the motion will become helical. Charge and Mass of the Particle (q and m): - The charge q affects the force exerted on the particle by the magnetic field. A greater charge leads to a larger Lorentz force, influencing the radius of the motion. - The mass m of the particle determines the inertia of the particle, and thus, a heavier particle will have a larger radius of motion under the same field strength and velocity. Suggested Variations to Try Parameter Try Changing From Expected Effect \\(\\vec{B}\\) \\([0, 0, 1] \\rightarrow [0, 0, 2]\\) Tighter spirals \\(\\vec{E}\\) \\([0.5, 0, 0] \\rightarrow [0, 0, 1]\\) Helical \u2192 Accelerated spiral \\(\\vec{v}_0\\) \\([1, 0, 0] \\rightarrow [0, 0, 1]\\) Circular \u2192 Linear motion \\(q\\) \\(1 \\rightarrow -1\\) Reverse rotation direction \\(m\\) \\(1 \\rightarrow 0.1\\) Faster spirals (lighter particle) const sliderDefs = [ { id: 'q', label: 'Charge (q)', min: -2, max: 2, step: 0.1, value: 1 }, { id: 'm', label: 'Mass (m)', min: 0.1, max: 5, step: 0.1, value: 1 }, { id: 'Ex', label: 'E_x', min: -2, max: 2, step: 0.1, value: 0 }, { id: 'Ey', label: 'E_y', min: -2, max: 2, step: 0.1, value: 0 }, { id: 'Ez', label: 'E_z', min: -2, max: 2, step: 0.1, value: 0 }, { id: 'Bx', label: 'B_x', min: -2, max: 2, step: 0.1, value: 0 }, { id: 'By', label: 'B_y', min: -2, max: 2, step: 0.1, value: 0 }, { id: 'Bz', label: 'B_z', min: -2, max: 2, step: 0.1, value: 1 }, { id: 'vx', label: 'v_x', min: -2, max: 2, step: 0.1, value: 1 }, { id: 'vy', label: 'v_y', min: -2, max: 2, step: 0.1, value: 0 }, { id: 'vz', label: 'v_z', min: -2, max: 2, step: 0.1, value: 0 } ]; const sliders = {}; const slidersDiv = document.getElementById('sliders'); sliderDefs.forEach(def => { const wrapper = document.createElement('div'); wrapper.className = 'slider'; const label = document.createElement('label'); label.innerText = def.label; const input = document.createElement('input'); input.type = 'range'; input.min = def.min; input.max = def.max; input.step = def.step; input.value = def.value; input.id = def.id; const valueDisplay = document.createElement('span'); valueDisplay.innerText = ` ${input.value}`; input.oninput = () => { valueDisplay.innerText = ` ${input.value}`; plotTrajectory(); // update on slider change }; wrapper.appendChild(label); wrapper.appendChild(input); wrapper.appendChild(valueDisplay); slidersDiv.appendChild(wrapper); sliders[def.id] = input; }); function simulateParticle(q, m, E, B, v0, r0 = [0, 0, 0], dt = 0.01, steps = 1000) { let r = Array(steps).fill().map(() => [0, 0, 0]); let v = Array(steps).fill().map(() => [0, 0, 0]); r[0] = [...r0]; v[0] = [...v0]; const cross = (a, b) => [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ]; for (let i = 1; i < steps; i++) { const crossVB = cross(v[i - 1], B); const F = E.map((Ei, j) => q * (Ei + crossVB[j])); const a = F.map(f => f / m); v[i] = v[i - 1].map((vi, j) => vi + a[j] * dt); r[i] = r[i - 1].map((ri, j) => ri + v[i][j] * dt); } return r; } function plotTrajectory() { const q = parseFloat(sliders.q.value); const m = parseFloat(sliders.m.value); const E = [parseFloat(sliders.Ex.value), parseFloat(sliders.Ey.value), parseFloat(sliders.Ez.value)]; const B = [parseFloat(sliders.Bx.value), parseFloat(sliders.By.value), parseFloat(sliders.Bz.value)]; const v0 = [parseFloat(sliders.vx.value), parseFloat(sliders.vy.value), parseFloat(sliders.vz.value)]; const r = simulateParticle(q, m, E, B, v0); const x = r.map(p => p[0]); const y = r.map(p => p[1]); const z = r.map(p => p[2]); const trace = { x, y, z, type: 'scatter3d', mode: 'lines', name: 'Trajectory', line: { width: 4 } }; const start = { x: [x[0]], y: [y[0]], z: [z[0]], type: 'scatter3d', mode: 'markers', marker: { size: 5, color: 'green' }, name: 'Start' }; const end = { x: [x[x.length - 1]], y: [y[y.length - 1]], z: [z[z.length - 1]], type: 'scatter3d', mode: 'markers', marker: { size: 5, color: 'red' }, name: 'End' }; const layout = { scene: { xaxis: { title: 'X' }, yaxis: { title: 'Y' }, zaxis: { title: 'Z' } }, margin: { l: 0, r: 0, t: 40, b: 0 } }; Plotly.newPlot('plot', [trace, start, end], layout); } plotTrajectory(); // initial plot Field Strengths ( \\(\\vec{E}, \\vec{B}\\) ) Stronger \\(\\vec{B}\\) \u2192 tighter spirals (smaller radius, faster cycles) Stronger \\(\\vec{E}\\) \u2192 more acceleration/drift Initial Velocity ( \\(\\vec{v}_0\\) ) Controls direction and shape of trajectory Component perpendicular to \\(\\vec{B}\\) \u2192 circular motion Component parallel to \\(\\vec{B}\\) \u2192 helical motion Charge ( \\(q\\) ) and Mass ( \\(m\\) ) Affects acceleration: $$ \\vec{a} = \\frac{q}{m} \\left( \\vec{E} + \\vec{v} \\times \\vec{B} \\right) $$ Heavier particles \u2192 move more slowly, spiral wider By varying field strengths, initial velocities, charge, and mass, we observe: Circular or helical motion under magnetic fields Acceleration or drift under electric fields Trajectory shape and speed heavily influenced by \\(\\frac{q}{m}\\) Direction reversal when charge flips","title":"Parameter Exploration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#visualization","text":"Show particle motion under various field configurations using clear, labeled plots . Emphasize key features such as: Larmor radius : Radius of circular motion in a magnetic field Drift velocity : Constant velocity perpendicular to both \\(\\vec{E}\\) and \\(\\vec{B}\\) Larmor Radius The radius of circular motion in a magnetic field: \\[ r_L = \\frac{m v_\\perp}{|q| B} \\] \\(v_\\perp\\) : component of velocity perpendicular to \\(\\vec{B}\\) \\(B\\) : magnetic field magnitude \\(q\\) : particle charge \\(m\\) : particle mass Drift Velocity (for crossed \\(\\vec{E} \\times \\vec{B}\\) fields): \\[ \\vec{v}_d = \\frac{\\vec{E} \\times \\vec{B}}{B^2} \\] This velocity is independent of charge and mass Direction is perpendicular to both \\(\\vec{E}\\) and \\(\\vec{B}\\) 2D Plot (e.g., x-y plane): Shows circular motion plus drift Larmor radius indicated as a dashed circle Drift velocity shown with an arrow 3D Plot : Displays full trajectory (helical or linear drift) Vector arrows for \\(\\vec{E}\\) and \\(\\vec{B}\\) for reference Visualizes how fields influence particle path in space Visualization Summary A charged particle follows a helical or drift path depending on the field configuration Larmor radius determines the size of the circular motion in a magnetic field In crossed \\(\\vec{E} \\times \\vec{B}\\) fields, the particle drifts at constant speed perpendicular to both fields These visuals help explain energy transfer and particle control in devices like mass spectrometers and plasma traps","title":"Visualization"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Equivalent Resistance Using Graph Theory Calculating Equivalent Resistance Using Graph Theory Calculating equivalent resistance is a fundamental problem in electrical circuits, essential for understanding and designing efficient systems. Traditional methods\u2014based on applying series and parallel resistor rules\u2014work well for simple setups but can become unwieldy for complex networks with many components. Graph theory offers a powerful and systematic alternative for analyzing such circuits. By modeling a circuit as a graph\u2014where nodes represent junctions and edges represent resistors weighted by their resistance values\u2014we can algorithmically simplify and solve intricate networks. This graph-based approach not only streamlines manual calculations but also enables automated circuit analysis, making it particularly valuable in applications like simulation software, optimization, and large-scale network design. Beyond its practical utility, studying equivalent resistance through graph theory provides deeper insight into the intersection of electrical engineering and mathematics. It showcases the broad applicability of graph theory across disciplines such as physics, engineering, and computer science. Equivalent Resistance Using Graph Theory To calculate the equivalent resistance using graph theory, the circuit is first converted into a graph where: Nodes represent electrical junctions. Edges represent resistors with weights corresponding to resistance values. The algorithm then works by identifying series and parallel resistor configurations and systematically reducing them: Series : Two resistors are in series if they are the only components connected between two nodes (degree 2, non-branching). Parallel : Resistors are in parallel if they connect the same pair of nodes. The goal is to simplify the graph iteratively by identifying series and parallel connections of resistors, and replacing them with an equivalent single resistor, until only one equivalent resistance remains. We can use graph traversal techniques, such as Depth-First Search (DFS), to identify series and parallel combinations and reduce the graph accordingly. Key Concepts: Series Connection : Resistors in series simply add up: \\[ R_{eq} = R_1 + R_2 + \\dots + R_n \\] Parallel Connection : Resistors in parallel combine according to the reciprocal rule: \\[ \\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\dots + \\frac{1}{R_n} \\] Pseudocode for Algorithm # Define a function that calculates the equivalent resistance using graph theory def calculate_equivalent_resistance(graph): while len(graph.nodes) > 1: # Continue until we have one node left # Step 1: Identify series connections for edge in graph.edges: if is_series_connection(edge): # Combine the resistances of the series connection combined_resistance = sum([edge.weight for edge in edge_list]) graph.update_edge(edge, combined_resistance) break # Step 2: Identify parallel connections for edge in graph.edges: if is_parallel_connection(edge): # Combine the resistances of the parallel connection combined_resistance = 1 / sum([1 / edge.weight for edge in edge_list]) graph.update_edge(edge, combined_resistance) break # Return the equivalent resistance (final remaining node's weight) return graph.get_node_weight(graph.nodes[0]) # Helper function to detect if a set of resistors are in series def is_series_connection(edge): # Two resistors are in series if they are directly connected without any branching return edge.node_a in edge.node_b # Helper function to detect if a set of resistors are in parallel def is_parallel_connection(edge): # Resistors are in parallel if they are connected at the same nodes return edge.node_a == edge.node_b # Graph class definition to represent the network of resistors class Graph: def __init__(self): self.nodes = {} # stores node references self.edges = {} # stores edge data: (node1, node2) -> resistance_value def add_edge(self, node1, node2, resistance): # Add an edge between node1 and node2 with given resistance self.edges[(node1, node2)] = resistance def get_node_weight(self, node): # Returns the current resistance of the node (calculated iteratively) pass def update_edge(self, edge, new_resistance): # Update the edge with the new resistance self.edges[edge] = new_resistance Python Code import networkx as nx def calculate_equivalent_resistance(G, start, end): while True: simplified = False # Check for series connections for node in list(G.nodes): neighbors = list(G.neighbors(node)) if len(neighbors) == 2 and node not in (start, end): n1, n2 = neighbors r1 = G[node][n1]['resistance'] r2 = G[node][n2]['resistance'] G.remove_node(node) G.add_edge(n1, n2, resistance=r1 + r2) simplified = True break if simplified: continue # Check for parallel edges for u, v in list(G.edges): parallel_edges = [e for e in G.edges if set(e) == set((u, v))] if len(parallel_edges) > 1: resistances = [G[edge[0]][edge[1]]['resistance'] for edge in parallel_edges] for edge in parallel_edges: G.remove_edge(*edge) combined_resistance = 1 / sum(1/r for r in resistances) G.add_edge(u, v, resistance=combined_resistance) simplified = True break if not simplified: break try: # Assume a single path from start to end now return G[start][end]['resistance'] except KeyError: raise ValueError(\"Cannot reduce to a single equivalent resistance between given nodes.\") # Example usage def main(): G = nx.Graph() G.add_edge('A', 'B', resistance=2) # R1 G.add_edge('B', 'C', resistance=3) # R2 G.add_edge('C', 'D', resistance=5) # R3 eq_resistance = calculate_equivalent_resistance(G, 'A', 'D') print(f\"Equivalent Resistance between A and D: {eq_resistance} Ohms\") if __name__ == \"__main__\": main() Output should be: Equivalent Resistance between A and D: 10 Ohms Explanation: Graph Representation : The graph is created using a Graph class where edges represent resistors, and each edge has a weight representing the resistance. Identifying Series Connections : In the is_series_connection function, we check if two nodes are directly connected with no branching, meaning they are in series. Identifying Parallel Connections : In the is_parallel_connection function, we check if two nodes are connected at the same junction, which means they are in parallel. Iterative Simplification : The calculate_equivalent_resistance function runs iteratively, continuously simplifying the circuit until only one node remains, which represents the total equivalent resistance. Handling Nested Combinations Nested combinations occur when there are both series and parallel connections within a circuit. The algorithm handles this by following these steps: Simplifying the Circuit : First, it checks for simple series or parallel connections and reduces them to equivalent resistances. Recursive Application : After each reduction, the algorithm rechecks the graph to see if new series or parallel combinations emerge due to the simplifications. Handling Deep Nesting : If the graph contains deeply nested combinations (e.g., a series of parallel combinations or vice versa), the algorithm will repeatedly simplify the graph until it reaches a final, reduced form. Examples and Analysis Simple Series Circuit Circuit : A simple series circuit with three resistors: \\(R_1 = 2\\,\\Omega\\) , \\(R_2 = 3\\,\\Omega\\) , \\(R_3 = 5\\,\\Omega\\) . Graph Representation : Nodes are connected in a straight line (no branching), so all resistors are in series. Simplification : The equivalent resistance is: \\[ R_{\\text{eq}} = R_1 + R_2 + R_3 = 2 + 3 + 5 = 10\\,\\Omega \\] Simple Parallel Circuit Circuit : Two resistors in parallel: \\(R_1 = 2\\,\\Omega\\) and \\(R_2 = 3\\,\\Omega\\) . Graph Representation : The resistors are connected between the same two nodes. Simplification : The equivalent resistance is: \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} = \\frac{1}{2} + \\frac{1}{3} \\approx 0.833 \\] So, \\[ R_{\\text{eq}} \\approx 1.2\\,\\Omega \\] Mixed Series-Parallel Circuit Circuit : Three resistors: \\(R_1 = 2\\,\\Omega\\) in series with a parallel combination of \\(R_2 = 3\\,\\Omega\\) and \\(R_3 = 5\\,\\Omega\\) . Graph Representation : First simplify the parallel resistors, then add \\(R_1\\) . Simplification : First, calculate the parallel combination: \\[ \\frac{1}{R_{\\parallel}} = \\frac{1}{3} + \\frac{1}{5} = \\frac{8}{15} \\Rightarrow R_{\\parallel} = \\frac{15}{8} \\approx 1.88\\,\\Omega \\] Then, \\[ R_{\\text{eq}} = R_1 + R_{\\parallel} = 2 + 1.88 = 3.88\\,\\Omega \\] Algorithm Efficiency and Potential Improvements Efficiency: Time Complexity : The algorithm involves iterating over the graph to identify series and parallel combinations, which can be done in linear time for each edge. Therefore, the time complexity depends on the number of edges and nodes in the graph. In the worst case, this can be \\(O(E)\\) , where \\(E\\) is the number of edges. Space Complexity : The space complexity is \\(O(N + E)\\) , where \\(N\\) is the number of nodes and \\(E\\) is the number of edges, as the graph structure needs to store both. Potential Improvements: Optimizing Traversal : Instead of checking all edges, we could prioritize edges that are more likely to lead to simplifications, reducing unnecessary iterations. Advanced Graph Algorithms : Incorporating more advanced graph algorithms, such as those used in network flow analysis, could improve performance for larger, more complex circuits. Parallel Computation : For very large circuits, parallelizing the algorithm could significantly reduce computation time, especially when simplifying disconnected components.","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-using-graph-theory","text":"","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#calculating-equivalent-resistance-using-graph-theory","text":"Calculating equivalent resistance is a fundamental problem in electrical circuits, essential for understanding and designing efficient systems. Traditional methods\u2014based on applying series and parallel resistor rules\u2014work well for simple setups but can become unwieldy for complex networks with many components. Graph theory offers a powerful and systematic alternative for analyzing such circuits. By modeling a circuit as a graph\u2014where nodes represent junctions and edges represent resistors weighted by their resistance values\u2014we can algorithmically simplify and solve intricate networks. This graph-based approach not only streamlines manual calculations but also enables automated circuit analysis, making it particularly valuable in applications like simulation software, optimization, and large-scale network design. Beyond its practical utility, studying equivalent resistance through graph theory provides deeper insight into the intersection of electrical engineering and mathematics. It showcases the broad applicability of graph theory across disciplines such as physics, engineering, and computer science.","title":"Calculating Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-using-graph-theory_1","text":"To calculate the equivalent resistance using graph theory, the circuit is first converted into a graph where: Nodes represent electrical junctions. Edges represent resistors with weights corresponding to resistance values. The algorithm then works by identifying series and parallel resistor configurations and systematically reducing them: Series : Two resistors are in series if they are the only components connected between two nodes (degree 2, non-branching). Parallel : Resistors are in parallel if they connect the same pair of nodes. The goal is to simplify the graph iteratively by identifying series and parallel connections of resistors, and replacing them with an equivalent single resistor, until only one equivalent resistance remains. We can use graph traversal techniques, such as Depth-First Search (DFS), to identify series and parallel combinations and reduce the graph accordingly.","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#key-concepts","text":"Series Connection : Resistors in series simply add up: \\[ R_{eq} = R_1 + R_2 + \\dots + R_n \\] Parallel Connection : Resistors in parallel combine according to the reciprocal rule: \\[ \\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\dots + \\frac{1}{R_n} \\]","title":"Key Concepts:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#pseudocode-for-algorithm","text":"# Define a function that calculates the equivalent resistance using graph theory def calculate_equivalent_resistance(graph): while len(graph.nodes) > 1: # Continue until we have one node left # Step 1: Identify series connections for edge in graph.edges: if is_series_connection(edge): # Combine the resistances of the series connection combined_resistance = sum([edge.weight for edge in edge_list]) graph.update_edge(edge, combined_resistance) break # Step 2: Identify parallel connections for edge in graph.edges: if is_parallel_connection(edge): # Combine the resistances of the parallel connection combined_resistance = 1 / sum([1 / edge.weight for edge in edge_list]) graph.update_edge(edge, combined_resistance) break # Return the equivalent resistance (final remaining node's weight) return graph.get_node_weight(graph.nodes[0]) # Helper function to detect if a set of resistors are in series def is_series_connection(edge): # Two resistors are in series if they are directly connected without any branching return edge.node_a in edge.node_b # Helper function to detect if a set of resistors are in parallel def is_parallel_connection(edge): # Resistors are in parallel if they are connected at the same nodes return edge.node_a == edge.node_b # Graph class definition to represent the network of resistors class Graph: def __init__(self): self.nodes = {} # stores node references self.edges = {} # stores edge data: (node1, node2) -> resistance_value def add_edge(self, node1, node2, resistance): # Add an edge between node1 and node2 with given resistance self.edges[(node1, node2)] = resistance def get_node_weight(self, node): # Returns the current resistance of the node (calculated iteratively) pass def update_edge(self, edge, new_resistance): # Update the edge with the new resistance self.edges[edge] = new_resistance","title":"Pseudocode for Algorithm"},{"location":"1%20Physics/5%20Circuits/Problem_1/#python-code","text":"import networkx as nx def calculate_equivalent_resistance(G, start, end): while True: simplified = False # Check for series connections for node in list(G.nodes): neighbors = list(G.neighbors(node)) if len(neighbors) == 2 and node not in (start, end): n1, n2 = neighbors r1 = G[node][n1]['resistance'] r2 = G[node][n2]['resistance'] G.remove_node(node) G.add_edge(n1, n2, resistance=r1 + r2) simplified = True break if simplified: continue # Check for parallel edges for u, v in list(G.edges): parallel_edges = [e for e in G.edges if set(e) == set((u, v))] if len(parallel_edges) > 1: resistances = [G[edge[0]][edge[1]]['resistance'] for edge in parallel_edges] for edge in parallel_edges: G.remove_edge(*edge) combined_resistance = 1 / sum(1/r for r in resistances) G.add_edge(u, v, resistance=combined_resistance) simplified = True break if not simplified: break try: # Assume a single path from start to end now return G[start][end]['resistance'] except KeyError: raise ValueError(\"Cannot reduce to a single equivalent resistance between given nodes.\") # Example usage def main(): G = nx.Graph() G.add_edge('A', 'B', resistance=2) # R1 G.add_edge('B', 'C', resistance=3) # R2 G.add_edge('C', 'D', resistance=5) # R3 eq_resistance = calculate_equivalent_resistance(G, 'A', 'D') print(f\"Equivalent Resistance between A and D: {eq_resistance} Ohms\") if __name__ == \"__main__\": main() Output should be: Equivalent Resistance between A and D: 10 Ohms","title":"Python Code"},{"location":"1%20Physics/5%20Circuits/Problem_1/#explanation","text":"Graph Representation : The graph is created using a Graph class where edges represent resistors, and each edge has a weight representing the resistance. Identifying Series Connections : In the is_series_connection function, we check if two nodes are directly connected with no branching, meaning they are in series. Identifying Parallel Connections : In the is_parallel_connection function, we check if two nodes are connected at the same junction, which means they are in parallel. Iterative Simplification : The calculate_equivalent_resistance function runs iteratively, continuously simplifying the circuit until only one node remains, which represents the total equivalent resistance.","title":"Explanation:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#handling-nested-combinations","text":"Nested combinations occur when there are both series and parallel connections within a circuit. The algorithm handles this by following these steps: Simplifying the Circuit : First, it checks for simple series or parallel connections and reduces them to equivalent resistances. Recursive Application : After each reduction, the algorithm rechecks the graph to see if new series or parallel combinations emerge due to the simplifications. Handling Deep Nesting : If the graph contains deeply nested combinations (e.g., a series of parallel combinations or vice versa), the algorithm will repeatedly simplify the graph until it reaches a final, reduced form.","title":"Handling Nested Combinations"},{"location":"1%20Physics/5%20Circuits/Problem_1/#examples-and-analysis","text":"","title":"Examples and Analysis"},{"location":"1%20Physics/5%20Circuits/Problem_1/#simple-series-circuit","text":"Circuit : A simple series circuit with three resistors: \\(R_1 = 2\\,\\Omega\\) , \\(R_2 = 3\\,\\Omega\\) , \\(R_3 = 5\\,\\Omega\\) . Graph Representation : Nodes are connected in a straight line (no branching), so all resistors are in series. Simplification : The equivalent resistance is: \\[ R_{\\text{eq}} = R_1 + R_2 + R_3 = 2 + 3 + 5 = 10\\,\\Omega \\]","title":"Simple Series Circuit"},{"location":"1%20Physics/5%20Circuits/Problem_1/#simple-parallel-circuit","text":"Circuit : Two resistors in parallel: \\(R_1 = 2\\,\\Omega\\) and \\(R_2 = 3\\,\\Omega\\) . Graph Representation : The resistors are connected between the same two nodes. Simplification : The equivalent resistance is: \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} = \\frac{1}{2} + \\frac{1}{3} \\approx 0.833 \\] So, \\[ R_{\\text{eq}} \\approx 1.2\\,\\Omega \\]","title":"Simple Parallel Circuit"},{"location":"1%20Physics/5%20Circuits/Problem_1/#mixed-series-parallel-circuit","text":"Circuit : Three resistors: \\(R_1 = 2\\,\\Omega\\) in series with a parallel combination of \\(R_2 = 3\\,\\Omega\\) and \\(R_3 = 5\\,\\Omega\\) . Graph Representation : First simplify the parallel resistors, then add \\(R_1\\) . Simplification : First, calculate the parallel combination: \\[ \\frac{1}{R_{\\parallel}} = \\frac{1}{3} + \\frac{1}{5} = \\frac{8}{15} \\Rightarrow R_{\\parallel} = \\frac{15}{8} \\approx 1.88\\,\\Omega \\] Then, \\[ R_{\\text{eq}} = R_1 + R_{\\parallel} = 2 + 1.88 = 3.88\\,\\Omega \\]","title":"Mixed Series-Parallel Circuit"},{"location":"1%20Physics/5%20Circuits/Problem_1/#algorithm-efficiency-and-potential-improvements","text":"","title":"Algorithm Efficiency and Potential Improvements"},{"location":"1%20Physics/5%20Circuits/Problem_1/#efficiency","text":"Time Complexity : The algorithm involves iterating over the graph to identify series and parallel combinations, which can be done in linear time for each edge. Therefore, the time complexity depends on the number of edges and nodes in the graph. In the worst case, this can be \\(O(E)\\) , where \\(E\\) is the number of edges. Space Complexity : The space complexity is \\(O(N + E)\\) , where \\(N\\) is the number of nodes and \\(E\\) is the number of edges, as the graph structure needs to store both.","title":"Efficiency:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#potential-improvements","text":"Optimizing Traversal : Instead of checking all edges, we could prioritize edges that are more likely to lead to simplifications, reducing unnecessary iterations. Advanced Graph Algorithms : Incorporating more advanced graph algorithms, such as those used in network flow analysis, could improve performance for larger, more complex circuits. Parallel Computation : For very large circuits, parallelizing the algorithm could significantly reduce computation time, especially when simplifying disconnected components.","title":"Potential Improvements:"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Exploring the Central Limit Theorem through simulations The Central Limit Theorem (CLT) is a foundational principle in probability and statistics. It states that as the size of a sample increases, the distribution of the sample mean tends to approximate a normal distribution, no matter the shape of the original population distribution. This remarkable property enables statisticians to make inferences about population parameters even when the data are not normally distributed. Simulating Sampling Distributions We'll generate large populations using three types of distributions: To simulate the Central Limit Theorem, we must first create large datasets (populations) from which we can draw random samples. The Central Limit Theorem (CLT) shows that no matter the original distribution (here, uniform), as the sample size increases, the sampling distribution of the sample mean approximates a normal distribution. Despite the exponential distribution being right-skewed , the sample means normalize as the sample size increases, illustrating the CLT's power to make sampling distributions normal even from skewed populations. The CLT transforms the discrete binomial distribution into a normal distribution as the sample size increases, allowing for easier statistical analysis. import matplotlib.pyplot as plt import seaborn as sns # For reproducibility np.random.seed(42) # Step 1: Define population size N = 100000 # A large sample to represent the population # Step 2: Generate different types of populations # 1. Uniform distribution (values between 0 and 1) uniform_pop = np.random.uniform(low=0, high=1, size=N) # 2. Exponential distribution (scale = 1) exponential_pop = np.random.exponential(scale=1.0, size=N) # 3. Binomial distribution (n=10 trials, p=0.5 success probability) binomial_pop = np.random.binomial(n=10, p=0.5, size=N) # Step 3: Create a dictionary for easier iteration populations = { 'Uniform': uniform_pop, 'Exponential': exponential_pop, 'Binomial': binomial_pop } # Step 4: Set the style and color palette sns.set(style=\"whitegrid\") # Sets background style for better readability palette = sns.color_palette(\"viridis\", as_cmap=True) # Smooth color map for better aesthetics # Step 5: Plot each population distribution and save individually for i, (name, data) in enumerate(populations.items()): # Create the plot for each population plt.figure(figsize=(8, 6)) # Adjust figure size sns.histplot(data, bins=50, stat='density', color=palette(i / 3), linewidth=1.5) # Customize the plot plt.title(f'{name} Population', fontsize=14, weight='bold') plt.xlabel('Value', fontsize=12) plt.ylabel('Density', fontsize=12) plt.grid(True, linestyle='--', alpha=0.6) # Save the plot to a PNG file plt.tight_layout() plt.savefig(f\"{name}_population.png\") # Save each plot as a separate file plt.close() # Close the figure to prevent overlap in the next plot print(\"Plots saved successfully!\") Sampling and Visualization We will take random samples from the population and compute the sample mean for each sample. We'll repeat this process multiple times to create a sampling distribution for each sample size. We'll plot histograms of the sample means and observe how the sampling distribution approaches a normal distribution as the sample size increases. We will calculate the mean (average) of that sample by summing the values and dividing by the number of items in the sample. \\[ \\bar{x} = \\frac{1}{n} \\sum_{i=1}^{n} x_i \\] \\(\\bar{x}\\) is the sample mean \\(n\\) is the sample size \\(x_i\\) are the individual data values in the sample The plot shows sampling distributions of the mean for different sample sizes (5, 10, 30, 50) drawn from the same normal population. Each colored histogram represents the distribution of 1,000 sample means , where: - A sample of a given size is randomly taken from the population. - The mean of that sample is computed. - This process is repeated 1,000 times to build the histogram. This demonstrates the Central Limit Theorem : as sample size increases, the sampling distribution of the mean becomes more normal and less variable , even when sampling from the same population. Parameter Exploration Shape of the Original Distribution - Normal population : The sampling distribution of the mean is normal regardless of sample size. - Skewed or non-normal populations (e.g., exponential, uniform): - For small sample sizes, the sampling distribution retains the skewness or shape of the population. - As sample size increases , the sampling distribution becomes more normal , even if the original distribution is not. Sample Size - Larger samples (e.g., \\(n=30\\) , \\(n=50\\) ) lead to: - Faster convergence to normality. - Smaller standard error (i.e., narrower distribution). - Smaller samples (e.g., \\(n=5\\) ) show more variability and reflect the original population more closely. Population Variance - The spread (standard deviation) of the sampling distribution of the mean is: $$ \\text{Standard Error} = \\frac{\\sigma}{\\sqrt{n}} $$ - \\(\\sigma\\) : population standard deviation - \\(n\\) : sample size Higher variance in the population = wider sampling distributions, even as the shape becomes normal. Practical Applications The Central Limit Theorem (CLT) is one of the most powerful concepts in statistics, with broad practical applications across many fields . Here's how it plays a vital role in real-world scenarios: Estimating Population Parameters In surveys, medical trials, and experiments, we rarely have access to entire populations. CLT allows us to use sample means (from random samples) to estimate the population mean with known accuracy. It also underpins confidence intervals and hypothesis testing by assuming the sampling distribution is approximately normal when the sample size is large enough. Quality Control in Manufacturing In industries like electronics or pharmaceuticals, it's impractical to test every product. Manufacturers take random samples from each production batch and use sample means to monitor consistency and detect defects. The CLT justifies the use of control charts (e.g., X\u0304 charts), because the distribution of sample means becomes normal , allowing for predictable control limits. Predicting Outcomes in Financial Models Finance often deals with returns from stocks, portfolios, or investments \u2014 all subject to variability. When modeling average returns over time or over different assets , CLT supports the assumption that the average return will be normally distributed , making statistical models more reliable. This is crucial for risk assessment , option pricing , and forecasting .","title":"Exploring the Central Limit Theorem through simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#exploring-the-central-limit-theorem-through-simulations","text":"The Central Limit Theorem (CLT) is a foundational principle in probability and statistics. It states that as the size of a sample increases, the distribution of the sample mean tends to approximate a normal distribution, no matter the shape of the original population distribution. This remarkable property enables statisticians to make inferences about population parameters even when the data are not normally distributed.","title":"Exploring the Central Limit Theorem through simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#simulating-sampling-distributions","text":"We'll generate large populations using three types of distributions: To simulate the Central Limit Theorem, we must first create large datasets (populations) from which we can draw random samples. The Central Limit Theorem (CLT) shows that no matter the original distribution (here, uniform), as the sample size increases, the sampling distribution of the sample mean approximates a normal distribution. Despite the exponential distribution being right-skewed , the sample means normalize as the sample size increases, illustrating the CLT's power to make sampling distributions normal even from skewed populations. The CLT transforms the discrete binomial distribution into a normal distribution as the sample size increases, allowing for easier statistical analysis. import matplotlib.pyplot as plt import seaborn as sns # For reproducibility np.random.seed(42) # Step 1: Define population size N = 100000 # A large sample to represent the population # Step 2: Generate different types of populations # 1. Uniform distribution (values between 0 and 1) uniform_pop = np.random.uniform(low=0, high=1, size=N) # 2. Exponential distribution (scale = 1) exponential_pop = np.random.exponential(scale=1.0, size=N) # 3. Binomial distribution (n=10 trials, p=0.5 success probability) binomial_pop = np.random.binomial(n=10, p=0.5, size=N) # Step 3: Create a dictionary for easier iteration populations = { 'Uniform': uniform_pop, 'Exponential': exponential_pop, 'Binomial': binomial_pop } # Step 4: Set the style and color palette sns.set(style=\"whitegrid\") # Sets background style for better readability palette = sns.color_palette(\"viridis\", as_cmap=True) # Smooth color map for better aesthetics # Step 5: Plot each population distribution and save individually for i, (name, data) in enumerate(populations.items()): # Create the plot for each population plt.figure(figsize=(8, 6)) # Adjust figure size sns.histplot(data, bins=50, stat='density', color=palette(i / 3), linewidth=1.5) # Customize the plot plt.title(f'{name} Population', fontsize=14, weight='bold') plt.xlabel('Value', fontsize=12) plt.ylabel('Density', fontsize=12) plt.grid(True, linestyle='--', alpha=0.6) # Save the plot to a PNG file plt.tight_layout() plt.savefig(f\"{name}_population.png\") # Save each plot as a separate file plt.close() # Close the figure to prevent overlap in the next plot print(\"Plots saved successfully!\")","title":"Simulating Sampling Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#sampling-and-visualization","text":"We will take random samples from the population and compute the sample mean for each sample. We'll repeat this process multiple times to create a sampling distribution for each sample size. We'll plot histograms of the sample means and observe how the sampling distribution approaches a normal distribution as the sample size increases. We will calculate the mean (average) of that sample by summing the values and dividing by the number of items in the sample. \\[ \\bar{x} = \\frac{1}{n} \\sum_{i=1}^{n} x_i \\] \\(\\bar{x}\\) is the sample mean \\(n\\) is the sample size \\(x_i\\) are the individual data values in the sample The plot shows sampling distributions of the mean for different sample sizes (5, 10, 30, 50) drawn from the same normal population. Each colored histogram represents the distribution of 1,000 sample means , where: - A sample of a given size is randomly taken from the population. - The mean of that sample is computed. - This process is repeated 1,000 times to build the histogram. This demonstrates the Central Limit Theorem : as sample size increases, the sampling distribution of the mean becomes more normal and less variable , even when sampling from the same population.","title":"Sampling and Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_1/#parameter-exploration","text":"Shape of the Original Distribution - Normal population : The sampling distribution of the mean is normal regardless of sample size. - Skewed or non-normal populations (e.g., exponential, uniform): - For small sample sizes, the sampling distribution retains the skewness or shape of the population. - As sample size increases , the sampling distribution becomes more normal , even if the original distribution is not. Sample Size - Larger samples (e.g., \\(n=30\\) , \\(n=50\\) ) lead to: - Faster convergence to normality. - Smaller standard error (i.e., narrower distribution). - Smaller samples (e.g., \\(n=5\\) ) show more variability and reflect the original population more closely. Population Variance - The spread (standard deviation) of the sampling distribution of the mean is: $$ \\text{Standard Error} = \\frac{\\sigma}{\\sqrt{n}} $$ - \\(\\sigma\\) : population standard deviation - \\(n\\) : sample size Higher variance in the population = wider sampling distributions, even as the shape becomes normal.","title":"Parameter Exploration"},{"location":"1%20Physics/6%20Statistics/Problem_1/#practical-applications","text":"The Central Limit Theorem (CLT) is one of the most powerful concepts in statistics, with broad practical applications across many fields . Here's how it plays a vital role in real-world scenarios: Estimating Population Parameters In surveys, medical trials, and experiments, we rarely have access to entire populations. CLT allows us to use sample means (from random samples) to estimate the population mean with known accuracy. It also underpins confidence intervals and hypothesis testing by assuming the sampling distribution is approximately normal when the sample size is large enough. Quality Control in Manufacturing In industries like electronics or pharmaceuticals, it's impractical to test every product. Manufacturers take random samples from each production batch and use sample means to monitor consistency and detect defects. The CLT justifies the use of control charts (e.g., X\u0304 charts), because the distribution of sample means becomes normal , allowing for predictable control limits. Predicting Outcomes in Financial Models Finance often deals with returns from stocks, portfolios, or investments \u2014 all subject to variability. When modeling average returns over time or over different assets , CLT supports the assumption that the average return will be normally distributed , making statistical models more reliable. This is crucial for risk assessment , option pricing , and forecasting .","title":"Practical Applications"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Estimating \u03c0 Using Monte Carlo Methods Monte Carlo simulations are a powerful class of computational techniques that use randomness to solve problems or estimate values. One particularly elegant application is the estimation of \\(\\pi\\) through geometric probability. By randomly generating points within a square and observing how many fall inside an inscribed circle, we can approximate \\(\\pi\\) in an intuitive and visually engaging way. This approach bridges key ideas from probability, geometry, and numerical computation\u2014offering not only a practical example of Monte Carlo methods but also a foundation for understanding how randomness is used to tackle complex problems in physics, finance, and computer science. Theoretical Foundation Monte Carlo methods allow us to estimate \\(\\pi\\) by leveraging geometric probability. By comparing the number of random points that fall inside a unit circle to the total number of points in the surrounding square, we can derive an estimate for \\(\\pi\\) : The unit circle is inscribed in a square with side length 2 (from \u22121 to 1 in both \\(x\\) and \\(y\\) ). The area of the square is 4. The area of the unit circle is \\(\\pi\\) . Therefore, the ratio of the areas is \\(\\pi / 4\\) . This leads to the estimation formula: \\[ \\pi \\approx 4 \\times \\left( \\frac{\\text{Points inside the circle}}{\\text{Total points}} \\right) \\] We estimate \\(\\pi\\) using the area ratio of a unit circle inscribed in a square: The area of a square with side length 2 (from \u22121 to 1) is \\(A_{\\text{square}} = 2^2 = 4\\) The area of the unit circle is \\(A_{\\text{circle}} = \\pi r^2 = \\pi(1)^2 = \\pi\\) By generating points uniformly within the square, the probability \\(P\\) that a point falls inside the circle is: \\[ A_{\\text{square}} = 2^2 = 4 \\] Rearranging gives us the current formula. Simulation and Visualization The circle-based Monte Carlo method is a straightforward yet powerful technique to estimate \\(\\pi\\) . By generating random points within a square that bounds a unit circle, we determine whether each point lies inside the circle based on the equation \\(x^2 + y^2 \\leq 1\\) . The simulation\u2019s effectiveness hinges on the law of large numbers\u2014as the number of random samples increases, the estimation of \\(\\pi\\) becomes more accurate. The visualization plays a crucial role in reinforcing the concept: Blue points indicate those that fall inside the circle. Red points fall outside the circle but within the square. Overlaying a visible circle provides an intuitive understanding of the proportion being measured. This method provides an interactive way to observe how randomness converges to a deterministic value. Additionally, the convergence plot ( \\(\\pi\\) vs. number of iterations) helps quantify the estimate's stability as the number of samples grows. Convergence and Efficiency The convergence rate of the estimate is proportional to \\(\\frac{1}{\\sqrt{N}}\\) , meaning that to gain one additional digit of accuracy, the number of samples must increase by a factor of 100. The computational cost scales linearly with the number of samples, but due to the simplicity of the calculations, the method is computationally efficient. However, achieving high precision requires a very large number of samples, making this method more educational than practical for computing \\(\\pi\\) to many decimal places. import numpy as np import matplotlib.pyplot as plt def monte_carlo_pi(num_points): x = np.random.uniform(-1, 1, num_points) y = np.random.uniform(-1, 1, num_points) inside = x**2 + y**2 < = 1 pi_estimate = 4 * np.sum(inside) / num_points return pi_estimate, x, y, inside def plot_simulation(x, y, inside, pi_estimate, num_points): fig, ax = plt.subplots(figsize=(6,6)) ax.set_aspect('equal') ax.set_title(f'Monte Carlo \u03c0 Estimate\\n\u03c0 \u2248 {pi_estimate:.6f} using {num_points} points') ax.scatter(x[inside], y[inside], color='blue', s=1, label='Inside Circle') ax.scatter(x[~inside], y[~inside], color='red', s=1, label='Outside Circle') ax.add_patch(plt.Circle((0, 0), 1, color='black', fill=False, linewidth=1)) ax.set_xlim(-1, 1) ax.set_ylim(-1, 1) ax.legend() plt.grid(True) plt.show() def plot_convergence(max_points, step=1000): estimates = [] points_range = range(step, max_points + 1, step) for n in points_range: pi_estimate, _, _, _ = monte_carlo_pi(n) estimates.append(pi_estimate) plt.figure(figsize=(10, 5)) plt.plot(points_range, estimates, label='Estimated \u03c0', color='green') plt.axhline(y=np.pi, color='black', linestyle='--', label='Actual \u03c0') plt.title('Convergence of \u03c0 Estimate') plt.xlabel('Number of Points') plt.ylabel('Estimated \u03c0') plt.legend() plt.grid(True) plt.show() # Example usage num_points = 10000 pi_estimate, x, y, inside = monte_carlo_pi(num_points) plot_simulation(x, y, inside, pi_estimate, num_points) # Convergence plot plot_convergence(50000, step=1000) Buffon\u2019s Needle Buffon\u2019s Needle is a famous problem where \\(\\pi\\) is estimated based on the probability of a needle crossing parallel lines: Floor has equally spaced parallel lines a distance \\(d\\) apart. Needle of length \\(l \\leq d\\) is randomly dropped. The probability of the needle crossing a line relates to \\(\\pi\\) . The formula is: \\[ \\pi \\approx \\frac{2 \\cdot l \\cdot N}{d \\cdot C} \\] Where: \\(l\\) : needle length \\(d\\) : distance between lines \\(N\\) : total throws \\(C\\) : crossings The probability of a crossing is derived using integral geometry: \\[ P(\\text{cross}) = \\frac{2l}{d\\pi} \\] So the expected number of crossings in \\(N\\) trials is: \\[ E[C] = N \\cdot P = N \\cdot \\frac{2l}{d\\pi} \\] Rearranging to solve for \\(\\pi\\) gives us the formula. Buffon's Needle simulation offers a fascinating probabilistic route to estimating \\(\\pi\\) . Each trial involves randomly dropping a needle onto a surface marked with evenly spaced parallel lines. Whether the needle crosses a line depends on both its angle and its position relative to the lines. By aggregating a large number of such random drops, the probability of a crossing approximates a known function of \\(\\pi\\) . In the visualization: Crossing needles can be highlighted (e.g., in red), while non-crossing ones remain in a neutral color. Parallel lines and needle orientations help visually interpret why a crossing does or does not occur. import numpy as np import matplotlib.pyplot as plt # Parameters needle_length = 1 line_spacing = 2 num_needles = 1000 # Generate random needle centers and angles x_centers = np.random.uniform(-line_spacing / 2, line_spacing / 2, num_needles) y_centers = np.random.uniform(0, 2, num_needles) angles = np.random.uniform(0, np.pi, num_needles) # Calculate needle endpoints x1 = x_centers - (needle_length / 2) * np.cos(angles) x2 = x_centers + (needle_length / 2) * np.cos(angles) y1 = y_centers - (needle_length / 2) * np.sin(angles) y2 = y_centers + (needle_length / 2) * np.sin(angles) # Determine crossings crosses = (np.floor(x1 / (line_spacing / 2)) != np.floor(x2 / (line_spacing / 2))) num_crosses = np.sum(crosses) # Estimate \u03c0 pi_estimate = (2 * needle_length * num_needles) / (line_spacing * num_crosses) # Plot plt.figure(figsize=(10, 6)) for i in range(num_needles): color = 'red' if crosses[i] else 'blue' plt.plot([x1[i], x2[i]], [y1[i], y2[i]], color=color, linewidth=0.5) # Draw parallel lines for i in range(-2, 3): plt.axvline(i * line_spacing / 2, color='gray', linestyle='--', linewidth=1) # Aesthetics plt.title(f\"Buffon's Needle Simulation\\nEstimated \u03c0 \u2248 {pi_estimate:.5f} (n={num_needles})\", fontsize=14) plt.xlabel(\"X Position (arbitrary units)\") Buffon's Method Comparison Buffon's method converges more slowly than the circle-based method, especially when the number of needle crossings is low (leading to higher variance). Since the method relies on trigonometric calculations and a more complex crossing condition, it is computationally more intensive. It provides historical and conceptual value but is less practical for large-scale precision estimation compared to simpler Monte Carlo methods. Conclusion Through this, we explored two classical Monte Carlo methods for estimating \\(\\pi\\) \u2014one based on geometric probability within a circle and another based on Buffon's Needle experiment. Both approaches demonstrated how randomness and statistical sampling can provide surprisingly accurate approximations of mathematical constants. While the circle-based method proved to be more computationally efficient and intuitive, Buffon\u2019s Needle offered historical context and a richer understanding of geometric probability. Ultimately, these simulations highlight the power and elegance of probabilistic thinking in solving problems that are otherwise analytically intractable.","title":"Estimating \u03c0 Using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-using-monte-carlo-methods","text":"Monte Carlo simulations are a powerful class of computational techniques that use randomness to solve problems or estimate values. One particularly elegant application is the estimation of \\(\\pi\\) through geometric probability. By randomly generating points within a square and observing how many fall inside an inscribed circle, we can approximate \\(\\pi\\) in an intuitive and visually engaging way. This approach bridges key ideas from probability, geometry, and numerical computation\u2014offering not only a practical example of Monte Carlo methods but also a foundation for understanding how randomness is used to tackle complex problems in physics, finance, and computer science.","title":"Estimating \u03c0 Using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#theoretical-foundation","text":"Monte Carlo methods allow us to estimate \\(\\pi\\) by leveraging geometric probability. By comparing the number of random points that fall inside a unit circle to the total number of points in the surrounding square, we can derive an estimate for \\(\\pi\\) : The unit circle is inscribed in a square with side length 2 (from \u22121 to 1 in both \\(x\\) and \\(y\\) ). The area of the square is 4. The area of the unit circle is \\(\\pi\\) . Therefore, the ratio of the areas is \\(\\pi / 4\\) . This leads to the estimation formula: \\[ \\pi \\approx 4 \\times \\left( \\frac{\\text{Points inside the circle}}{\\text{Total points}} \\right) \\] We estimate \\(\\pi\\) using the area ratio of a unit circle inscribed in a square: The area of a square with side length 2 (from \u22121 to 1) is \\(A_{\\text{square}} = 2^2 = 4\\) The area of the unit circle is \\(A_{\\text{circle}} = \\pi r^2 = \\pi(1)^2 = \\pi\\) By generating points uniformly within the square, the probability \\(P\\) that a point falls inside the circle is: \\[ A_{\\text{square}} = 2^2 = 4 \\] Rearranging gives us the current formula.","title":"Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#simulation-and-visualization","text":"The circle-based Monte Carlo method is a straightforward yet powerful technique to estimate \\(\\pi\\) . By generating random points within a square that bounds a unit circle, we determine whether each point lies inside the circle based on the equation \\(x^2 + y^2 \\leq 1\\) . The simulation\u2019s effectiveness hinges on the law of large numbers\u2014as the number of random samples increases, the estimation of \\(\\pi\\) becomes more accurate. The visualization plays a crucial role in reinforcing the concept: Blue points indicate those that fall inside the circle. Red points fall outside the circle but within the square. Overlaying a visible circle provides an intuitive understanding of the proportion being measured. This method provides an interactive way to observe how randomness converges to a deterministic value. Additionally, the convergence plot ( \\(\\pi\\) vs. number of iterations) helps quantify the estimate's stability as the number of samples grows.","title":"Simulation and Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#convergence-and-efficiency","text":"The convergence rate of the estimate is proportional to \\(\\frac{1}{\\sqrt{N}}\\) , meaning that to gain one additional digit of accuracy, the number of samples must increase by a factor of 100. The computational cost scales linearly with the number of samples, but due to the simplicity of the calculations, the method is computationally efficient. However, achieving high precision requires a very large number of samples, making this method more educational than practical for computing \\(\\pi\\) to many decimal places. import numpy as np import matplotlib.pyplot as plt def monte_carlo_pi(num_points): x = np.random.uniform(-1, 1, num_points) y = np.random.uniform(-1, 1, num_points) inside = x**2 + y**2 < = 1 pi_estimate = 4 * np.sum(inside) / num_points return pi_estimate, x, y, inside def plot_simulation(x, y, inside, pi_estimate, num_points): fig, ax = plt.subplots(figsize=(6,6)) ax.set_aspect('equal') ax.set_title(f'Monte Carlo \u03c0 Estimate\\n\u03c0 \u2248 {pi_estimate:.6f} using {num_points} points') ax.scatter(x[inside], y[inside], color='blue', s=1, label='Inside Circle') ax.scatter(x[~inside], y[~inside], color='red', s=1, label='Outside Circle') ax.add_patch(plt.Circle((0, 0), 1, color='black', fill=False, linewidth=1)) ax.set_xlim(-1, 1) ax.set_ylim(-1, 1) ax.legend() plt.grid(True) plt.show() def plot_convergence(max_points, step=1000): estimates = [] points_range = range(step, max_points + 1, step) for n in points_range: pi_estimate, _, _, _ = monte_carlo_pi(n) estimates.append(pi_estimate) plt.figure(figsize=(10, 5)) plt.plot(points_range, estimates, label='Estimated \u03c0', color='green') plt.axhline(y=np.pi, color='black', linestyle='--', label='Actual \u03c0') plt.title('Convergence of \u03c0 Estimate') plt.xlabel('Number of Points') plt.ylabel('Estimated \u03c0') plt.legend() plt.grid(True) plt.show() # Example usage num_points = 10000 pi_estimate, x, y, inside = monte_carlo_pi(num_points) plot_simulation(x, y, inside, pi_estimate, num_points) # Convergence plot plot_convergence(50000, step=1000)","title":"Convergence and Efficiency"},{"location":"1%20Physics/6%20Statistics/Problem_2/#buffons-needle","text":"Buffon\u2019s Needle is a famous problem where \\(\\pi\\) is estimated based on the probability of a needle crossing parallel lines: Floor has equally spaced parallel lines a distance \\(d\\) apart. Needle of length \\(l \\leq d\\) is randomly dropped. The probability of the needle crossing a line relates to \\(\\pi\\) . The formula is: \\[ \\pi \\approx \\frac{2 \\cdot l \\cdot N}{d \\cdot C} \\] Where: \\(l\\) : needle length \\(d\\) : distance between lines \\(N\\) : total throws \\(C\\) : crossings The probability of a crossing is derived using integral geometry: \\[ P(\\text{cross}) = \\frac{2l}{d\\pi} \\] So the expected number of crossings in \\(N\\) trials is: \\[ E[C] = N \\cdot P = N \\cdot \\frac{2l}{d\\pi} \\] Rearranging to solve for \\(\\pi\\) gives us the formula. Buffon's Needle simulation offers a fascinating probabilistic route to estimating \\(\\pi\\) . Each trial involves randomly dropping a needle onto a surface marked with evenly spaced parallel lines. Whether the needle crosses a line depends on both its angle and its position relative to the lines. By aggregating a large number of such random drops, the probability of a crossing approximates a known function of \\(\\pi\\) . In the visualization: Crossing needles can be highlighted (e.g., in red), while non-crossing ones remain in a neutral color. Parallel lines and needle orientations help visually interpret why a crossing does or does not occur. import numpy as np import matplotlib.pyplot as plt # Parameters needle_length = 1 line_spacing = 2 num_needles = 1000 # Generate random needle centers and angles x_centers = np.random.uniform(-line_spacing / 2, line_spacing / 2, num_needles) y_centers = np.random.uniform(0, 2, num_needles) angles = np.random.uniform(0, np.pi, num_needles) # Calculate needle endpoints x1 = x_centers - (needle_length / 2) * np.cos(angles) x2 = x_centers + (needle_length / 2) * np.cos(angles) y1 = y_centers - (needle_length / 2) * np.sin(angles) y2 = y_centers + (needle_length / 2) * np.sin(angles) # Determine crossings crosses = (np.floor(x1 / (line_spacing / 2)) != np.floor(x2 / (line_spacing / 2))) num_crosses = np.sum(crosses) # Estimate \u03c0 pi_estimate = (2 * needle_length * num_needles) / (line_spacing * num_crosses) # Plot plt.figure(figsize=(10, 6)) for i in range(num_needles): color = 'red' if crosses[i] else 'blue' plt.plot([x1[i], x2[i]], [y1[i], y2[i]], color=color, linewidth=0.5) # Draw parallel lines for i in range(-2, 3): plt.axvline(i * line_spacing / 2, color='gray', linestyle='--', linewidth=1) # Aesthetics plt.title(f\"Buffon's Needle Simulation\\nEstimated \u03c0 \u2248 {pi_estimate:.5f} (n={num_needles})\", fontsize=14) plt.xlabel(\"X Position (arbitrary units)\")","title":"Buffon\u2019s Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#buffons-method-comparison","text":"Buffon's method converges more slowly than the circle-based method, especially when the number of needle crossings is low (leading to higher variance). Since the method relies on trigonometric calculations and a more complex crossing condition, it is computationally more intensive. It provides historical and conceptual value but is less practical for large-scale precision estimation compared to simpler Monte Carlo methods.","title":"Buffon's Method Comparison"},{"location":"1%20Physics/6%20Statistics/Problem_2/#conclusion","text":"Through this, we explored two classical Monte Carlo methods for estimating \\(\\pi\\) \u2014one based on geometric probability within a circle and another based on Buffon's Needle experiment. Both approaches demonstrated how randomness and statistical sampling can provide surprisingly accurate approximations of mathematical constants. While the circle-based method proved to be more computationally efficient and intuitive, Buffon\u2019s Needle offered historical context and a richer understanding of geometric probability. Ultimately, these simulations highlight the power and elegance of probabilistic thinking in solving problems that are otherwise analytically intractable.","title":"Conclusion"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Measuring Earth's Gravitational Acceleration with a Pendulum Theoretical Background Equation for a simple pendulum: \\[ T = 2\\pi \\sqrt{\\frac{L}{g}} \\] Rearranged to solve for \\(g\\) : \\[ g = \\frac{4 \\pi^2 L}{T^2} \\] Where: \\(T\\) : Period of the pendulum (seconds) \\(L\\) : Length from pivot to the center of mass (meters) \\(g\\) : Acceleration due to gravity (m/s\u00b2) Pendulum Experiment Data L (m) \u0394L (m) T\u2081\u2080 (s) \u03c3T (s) \u0394T (s) g (m/s\u00b2) \u0394g (m/s\u00b2) 1.000 0.0005 20.12 0.027 0.0085 9.75 0.07 1.000 0.0005 20.15 0.031 0.0098 9.72 0.08 1.500 0.0005 25.18 0.033 0.0104 9.34 0.06 1.500 0.0005 25.14 0.029 0.0091 9.37 0.05 1.200 0.0005 22.14 0.027 0.0085 9.66 0.07 1.200 0.0005 22.19 0.030 0.0094 9.62 0.08 1.800 0.0005 27.35 0.027 0.0085 9.50 0.08 1.800 0.0005 27.31 0.029 0.0091 9.53 0.07 2.000 0.0005 29.25 0.031 0.0098 9.23 0.06 2.000 0.0005 29.28 0.027 0.0085 9.21 0.07 Calculations Determine the Period of One Oscillation The period \\(T\\) of a single oscillation is calculated by dividing the mean time for 10 oscillations by 10: \\[ T = \\frac{T_{10}}{10} \\] Determine the Uncertainty in the Period The uncertainty in the period, \\(\\Delta T\\) , is obtained by dividing the uncertainty in the mean time for 10 oscillations by 10: \\[ \\Delta T = \\frac{\\Delta T_{10}}{10} \\] These values of \\(T\\) and \\(\\Delta T\\) will be used in the next step to compute the gravitational acceleration and analyze uncertainty propagation. Determination of Gravitational Acceleration and Uncertainty Analysis The acceleration due to gravity, \\(g\\) , is calculated using the formula: \\[ g = \\frac{4\\pi^2 L}{T^2} \\] Where: \\(L\\) : Length of the pendulum (in meters) \\(T\\) : Period of one oscillation (in seconds) Propagation of Uncertainties To determine the uncertainty in \\(g\\) , denoted \\(\\Delta g\\) , we use the standard propagation of error formula. Since \\(g\\) depends on both \\(L\\) and \\(T\\) : \\[ \\frac{\\Delta g}{g} = \\sqrt{ \\left( \\frac{\\Delta L}{L} \\right)^2 + \\left( 2 \\cdot \\frac{\\Delta T}{T} \\right)^2 } \\] Therefore, the absolute uncertainty in \\(g\\) is: \\[ \\Delta g = g \\cdot \\sqrt{ \\left( \\frac{\\Delta L}{L} \\right)^2 + \\left( 2 \\cdot \\frac{\\Delta T}{T} \\right)^2 } \\] Final result: \\[ g = (\\text{value} \\pm \\Delta g)\\ \\text{m/s}^2 \\] Analysis Comparison with Standard Gravitational Acceleration The standard accepted value for gravitational acceleration at Earth's surface is: \\[ g_{\\text{standard}} = 9.81\\ \\text{m/s}^2 \\] Compare your experimentally determined value of \\(g\\) with this standard by calculating the percent error: \\[ \\text{Percent Error} = \\left| \\frac{g_{\\text{measured}} - g_{\\text{standard}}}{g_{\\text{standard}}} \\right| \\times 100\\% \\] If the measured value lies within the range \\(g_{\\text{standard}} \\pm \\Delta g\\) , the result is considered consistent within experimental uncertainty. If not, consider possible sources of discrepancy, such as: Reaction time delays in manual timing Inaccurate length measurement (e.g., not measuring to the center of mass) Air resistance or large angular displacements violating the small-angle approximation Non-rigid support allowing unwanted motion Effect of Measurement Resolution on \\(\\Delta L\\) The resolution of the measuring tool (e.g., ruler) directly determines the uncertainty in length, \\(\\Delta L\\) . For example, a 1 mm resolution yields: \\[ \\Delta L = \\pm 0.5\\,\\text{mm} \\] This propagates into the final value of \\(g\\) , though it has a smaller effect compared to timing uncertainty due to \\(g\\) \u2019s direct (not squared) dependence on \\(L\\) . Variability in Timing and Its Impact on \\(\\Delta T\\) Human reaction time introduces variability in timing measurements. Since \\(T\\) appears squared in the formula for \\(g\\) , even small uncertainties can significantly affect the result. Repeated measurements and statistical analysis help mitigate this impact. Assumptions and Experimental Limitations Small-Angle Approximation : Valid only for angles <15\u00b0. Larger angles introduce systematic errors. Negligible Air Resistance : Assumes damping is insignificant. Rigid Support and Frictionless Pivot : Idealized conditions that may not fully apply. Point Mass and Massless String : Simplified model; real systems deviate slightly. Uncertainty and Their Impact Human Error Introduces both random and systematic uncertainties. These increase \\(\\sigma_T\\) and consequently \\(\\Delta T\\) , which leads to greater \\(\\Delta g\\) . Resolution of Measuring Instruments Directly affects uncertainties in \\(L\\) and \\(T_{10}\\) , propagating through to \\(T\\) and \\(g\\) . Timing Since \\(g\\) depends on \\(T^2\\) , timing errors have an amplified impact on the uncertainty in \\(g\\) .","title":"Measuring Earth's Gravitational Acceleration with a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#measuring-earths-gravitational-acceleration-with-a-pendulum","text":"","title":"Measuring Earth's Gravitational Acceleration with a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#theoretical-background","text":"","title":"Theoretical Background"},{"location":"1%20Physics/7%20Measurements/Problem_1/#equation-for-a-simple-pendulum","text":"\\[ T = 2\\pi \\sqrt{\\frac{L}{g}} \\] Rearranged to solve for \\(g\\) : \\[ g = \\frac{4 \\pi^2 L}{T^2} \\] Where: \\(T\\) : Period of the pendulum (seconds) \\(L\\) : Length from pivot to the center of mass (meters) \\(g\\) : Acceleration due to gravity (m/s\u00b2)","title":"Equation for a simple pendulum:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#pendulum-experiment-data","text":"L (m) \u0394L (m) T\u2081\u2080 (s) \u03c3T (s) \u0394T (s) g (m/s\u00b2) \u0394g (m/s\u00b2) 1.000 0.0005 20.12 0.027 0.0085 9.75 0.07 1.000 0.0005 20.15 0.031 0.0098 9.72 0.08 1.500 0.0005 25.18 0.033 0.0104 9.34 0.06 1.500 0.0005 25.14 0.029 0.0091 9.37 0.05 1.200 0.0005 22.14 0.027 0.0085 9.66 0.07 1.200 0.0005 22.19 0.030 0.0094 9.62 0.08 1.800 0.0005 27.35 0.027 0.0085 9.50 0.08 1.800 0.0005 27.31 0.029 0.0091 9.53 0.07 2.000 0.0005 29.25 0.031 0.0098 9.23 0.06 2.000 0.0005 29.28 0.027 0.0085 9.21 0.07","title":"Pendulum Experiment Data"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculations","text":"","title":"Calculations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#determine-the-period-of-one-oscillation","text":"The period \\(T\\) of a single oscillation is calculated by dividing the mean time for 10 oscillations by 10: \\[ T = \\frac{T_{10}}{10} \\]","title":"Determine the Period of One Oscillation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#determine-the-uncertainty-in-the-period","text":"The uncertainty in the period, \\(\\Delta T\\) , is obtained by dividing the uncertainty in the mean time for 10 oscillations by 10: \\[ \\Delta T = \\frac{\\Delta T_{10}}{10} \\] These values of \\(T\\) and \\(\\Delta T\\) will be used in the next step to compute the gravitational acceleration and analyze uncertainty propagation.","title":"Determine the Uncertainty in the Period"},{"location":"1%20Physics/7%20Measurements/Problem_1/#determination-of-gravitational-acceleration-and-uncertainty-analysis","text":"The acceleration due to gravity, \\(g\\) , is calculated using the formula: \\[ g = \\frac{4\\pi^2 L}{T^2} \\] Where: \\(L\\) : Length of the pendulum (in meters) \\(T\\) : Period of one oscillation (in seconds)","title":"Determination of Gravitational Acceleration and Uncertainty Analysis"},{"location":"1%20Physics/7%20Measurements/Problem_1/#propagation-of-uncertainties","text":"To determine the uncertainty in \\(g\\) , denoted \\(\\Delta g\\) , we use the standard propagation of error formula. Since \\(g\\) depends on both \\(L\\) and \\(T\\) : \\[ \\frac{\\Delta g}{g} = \\sqrt{ \\left( \\frac{\\Delta L}{L} \\right)^2 + \\left( 2 \\cdot \\frac{\\Delta T}{T} \\right)^2 } \\] Therefore, the absolute uncertainty in \\(g\\) is: \\[ \\Delta g = g \\cdot \\sqrt{ \\left( \\frac{\\Delta L}{L} \\right)^2 + \\left( 2 \\cdot \\frac{\\Delta T}{T} \\right)^2 } \\] Final result: \\[ g = (\\text{value} \\pm \\Delta g)\\ \\text{m/s}^2 \\]","title":"Propagation of Uncertainties"},{"location":"1%20Physics/7%20Measurements/Problem_1/#analysis","text":"","title":"Analysis"},{"location":"1%20Physics/7%20Measurements/Problem_1/#comparison-with-standard-gravitational-acceleration","text":"The standard accepted value for gravitational acceleration at Earth's surface is: \\[ g_{\\text{standard}} = 9.81\\ \\text{m/s}^2 \\] Compare your experimentally determined value of \\(g\\) with this standard by calculating the percent error: \\[ \\text{Percent Error} = \\left| \\frac{g_{\\text{measured}} - g_{\\text{standard}}}{g_{\\text{standard}}} \\right| \\times 100\\% \\] If the measured value lies within the range \\(g_{\\text{standard}} \\pm \\Delta g\\) , the result is considered consistent within experimental uncertainty. If not, consider possible sources of discrepancy, such as: Reaction time delays in manual timing Inaccurate length measurement (e.g., not measuring to the center of mass) Air resistance or large angular displacements violating the small-angle approximation Non-rigid support allowing unwanted motion","title":"Comparison with Standard Gravitational Acceleration"},{"location":"1%20Physics/7%20Measurements/Problem_1/#effect-of-measurement-resolution-on-delta-l","text":"The resolution of the measuring tool (e.g., ruler) directly determines the uncertainty in length, \\(\\Delta L\\) . For example, a 1 mm resolution yields: \\[ \\Delta L = \\pm 0.5\\,\\text{mm} \\] This propagates into the final value of \\(g\\) , though it has a smaller effect compared to timing uncertainty due to \\(g\\) \u2019s direct (not squared) dependence on \\(L\\) .","title":"Effect of Measurement Resolution on \\(\\Delta L\\)"},{"location":"1%20Physics/7%20Measurements/Problem_1/#variability-in-timing-and-its-impact-on-delta-t","text":"Human reaction time introduces variability in timing measurements. Since \\(T\\) appears squared in the formula for \\(g\\) , even small uncertainties can significantly affect the result. Repeated measurements and statistical analysis help mitigate this impact.","title":"Variability in Timing and Its Impact on \\(\\Delta T\\)"},{"location":"1%20Physics/7%20Measurements/Problem_1/#assumptions-and-experimental-limitations","text":"Small-Angle Approximation : Valid only for angles <15\u00b0. Larger angles introduce systematic errors. Negligible Air Resistance : Assumes damping is insignificant. Rigid Support and Frictionless Pivot : Idealized conditions that may not fully apply. Point Mass and Massless String : Simplified model; real systems deviate slightly.","title":"Assumptions and Experimental Limitations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#uncertainty-and-their-impact","text":"","title":"Uncertainty and Their Impact"},{"location":"1%20Physics/7%20Measurements/Problem_1/#human-error","text":"Introduces both random and systematic uncertainties. These increase \\(\\sigma_T\\) and consequently \\(\\Delta T\\) , which leads to greater \\(\\Delta g\\) .","title":"Human Error"},{"location":"1%20Physics/7%20Measurements/Problem_1/#resolution-of-measuring-instruments","text":"Directly affects uncertainties in \\(L\\) and \\(T_{10}\\) , propagating through to \\(T\\) and \\(g\\) .","title":"Resolution of Measuring Instruments"},{"location":"1%20Physics/7%20Measurements/Problem_1/#timing","text":"Since \\(g\\) depends on \\(T^2\\) , timing errors have an amplified impact on the uncertainty in \\(g\\) .","title":"Timing"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}